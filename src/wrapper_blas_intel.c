/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (C) Martin Koehler, 2015
 */
 /* This file it automatically generated. Please do not edit. */
 /* Generated: Fri Sep 18 15:46:22 2015 */ 
        
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <complex.h>

#include "flexiblas.h"


#ifdef INTEGER8
#define blasint int64_t
#else 
#define blasint int 
#endif
#ifndef __INT32_MAX__
#define __INT32_MAX__ 2147483647
#endif 


int __flexiblas_load_fblas ( flexiblas_backend_t *handle, int *loaded, int *failed )  {
	int _ifailed = *failed;
	LOAD_FBLAS(handle,blas.caxpy,caxpy);
	LOAD_FBLAS(handle,blas.ccopy,ccopy);
	LOAD_FBLAS(handle,blas.cdotc,cdotc);
	LOAD_FBLAS(handle,blas.cdotu,cdotu);
	LOAD_FBLAS(handle,blas.cgbmv,cgbmv);
	LOAD_FBLAS(handle,blas.cgemm,cgemm);
	LOAD_FBLAS(handle,blas.cgemv,cgemv);
	LOAD_FBLAS(handle,blas.cgerc,cgerc);
	LOAD_FBLAS(handle,blas.cgeru,cgeru);
	LOAD_FBLAS(handle,blas.chbmv,chbmv);
	LOAD_FBLAS(handle,blas.chemm,chemm);
	LOAD_FBLAS(handle,blas.chemv,chemv);
	LOAD_FBLAS(handle,blas.cher,cher);
	LOAD_FBLAS(handle,blas.cher2,cher2);
	LOAD_FBLAS(handle,blas.cher2k,cher2k);
	LOAD_FBLAS(handle,blas.cherk,cherk);
	LOAD_FBLAS(handle,blas.chpmv,chpmv);
	LOAD_FBLAS(handle,blas.chpr,chpr);
	LOAD_FBLAS(handle,blas.chpr2,chpr2);
	LOAD_FBLAS(handle,blas.crotg,crotg);
	LOAD_FBLAS(handle,blas.cscal,cscal);
	LOAD_FBLAS(handle,blas.csrot,csrot);
	LOAD_FBLAS(handle,blas.csscal,csscal);
	LOAD_FBLAS(handle,blas.cswap,cswap);
	LOAD_FBLAS(handle,blas.csymm,csymm);
	LOAD_FBLAS(handle,blas.csyr2k,csyr2k);
	LOAD_FBLAS(handle,blas.csyrk,csyrk);
	LOAD_FBLAS(handle,blas.ctbmv,ctbmv);
	LOAD_FBLAS(handle,blas.ctbsv,ctbsv);
	LOAD_FBLAS(handle,blas.ctpmv,ctpmv);
	LOAD_FBLAS(handle,blas.ctpsv,ctpsv);
	LOAD_FBLAS(handle,blas.ctrmm,ctrmm);
	LOAD_FBLAS(handle,blas.ctrmv,ctrmv);
	LOAD_FBLAS(handle,blas.ctrsm,ctrsm);
	LOAD_FBLAS(handle,blas.ctrsv,ctrsv);
	LOAD_FBLAS(handle,blas.dasum,dasum);
	LOAD_FBLAS(handle,blas.daxpy,daxpy);
	LOAD_FBLAS(handle,blas.dcopy,dcopy);
	LOAD_FBLAS(handle,blas.ddot,ddot);
	LOAD_FBLAS(handle,blas.dgbmv,dgbmv);
	LOAD_FBLAS(handle,blas.dgemm,dgemm);
	LOAD_FBLAS(handle,blas.dgemv,dgemv);
	LOAD_FBLAS(handle,blas.dger,dger);
	LOAD_FBLAS(handle,blas.dnrm2,dnrm2);
	LOAD_FBLAS(handle,blas.drot,drot);
	LOAD_FBLAS(handle,blas.drotg,drotg);
	LOAD_FBLAS(handle,blas.drotm,drotm);
	LOAD_FBLAS(handle,blas.drotmg,drotmg);
	LOAD_FBLAS(handle,blas.dsbmv,dsbmv);
	LOAD_FBLAS(handle,blas.dscal,dscal);
	LOAD_FBLAS(handle,blas.dsdot,dsdot);
	LOAD_FBLAS(handle,blas.dspmv,dspmv);
	LOAD_FBLAS(handle,blas.dspr,dspr);
	LOAD_FBLAS(handle,blas.dspr2,dspr2);
	LOAD_FBLAS(handle,blas.dswap,dswap);
	LOAD_FBLAS(handle,blas.dsymm,dsymm);
	LOAD_FBLAS(handle,blas.dsymv,dsymv);
	LOAD_FBLAS(handle,blas.dsyr,dsyr);
	LOAD_FBLAS(handle,blas.dsyr2,dsyr2);
	LOAD_FBLAS(handle,blas.dsyr2k,dsyr2k);
	LOAD_FBLAS(handle,blas.dsyrk,dsyrk);
	LOAD_FBLAS(handle,blas.dtbmv,dtbmv);
	LOAD_FBLAS(handle,blas.dtbsv,dtbsv);
	LOAD_FBLAS(handle,blas.dtpmv,dtpmv);
	LOAD_FBLAS(handle,blas.dtpsv,dtpsv);
	LOAD_FBLAS(handle,blas.dtrmm,dtrmm);
	LOAD_FBLAS(handle,blas.dtrmv,dtrmv);
	LOAD_FBLAS(handle,blas.dtrsm,dtrsm);
	LOAD_FBLAS(handle,blas.dtrsv,dtrsv);
	LOAD_FBLAS(handle,blas.dzasum,dzasum);
	LOAD_FBLAS(handle,blas.dznrm2,dznrm2);
	LOAD_FBLAS(handle,blas.icamax,icamax);
	LOAD_FBLAS(handle,blas.idamax,idamax);
	LOAD_FBLAS(handle,blas.isamax,isamax);
	LOAD_FBLAS(handle,blas.izamax,izamax);
	LOAD_FBLAS(handle,blas.sasum,sasum);
	LOAD_FBLAS(handle,blas.saxpy,saxpy);
	LOAD_FBLAS(handle,blas.scasum,scasum);
	LOAD_FBLAS(handle,blas.scnrm2,scnrm2);
	LOAD_FBLAS(handle,blas.scopy,scopy);
	LOAD_FBLAS(handle,blas.sdot,sdot);
	LOAD_FBLAS(handle,blas.sdsdot,sdsdot);
	LOAD_FBLAS(handle,blas.sgbmv,sgbmv);
	LOAD_FBLAS(handle,blas.sgemm,sgemm);
	LOAD_FBLAS(handle,blas.sgemv,sgemv);
	LOAD_FBLAS(handle,blas.sger,sger);
	LOAD_FBLAS(handle,blas.snrm2,snrm2);
	LOAD_FBLAS(handle,blas.srot,srot);
	LOAD_FBLAS(handle,blas.srotg,srotg);
	LOAD_FBLAS(handle,blas.srotm,srotm);
	LOAD_FBLAS(handle,blas.srotmg,srotmg);
	LOAD_FBLAS(handle,blas.ssbmv,ssbmv);
	LOAD_FBLAS(handle,blas.sscal,sscal);
	LOAD_FBLAS(handle,blas.sspmv,sspmv);
	LOAD_FBLAS(handle,blas.sspr,sspr);
	LOAD_FBLAS(handle,blas.sspr2,sspr2);
	LOAD_FBLAS(handle,blas.sswap,sswap);
	LOAD_FBLAS(handle,blas.ssymm,ssymm);
	LOAD_FBLAS(handle,blas.ssymv,ssymv);
	LOAD_FBLAS(handle,blas.ssyr,ssyr);
	LOAD_FBLAS(handle,blas.ssyr2,ssyr2);
	LOAD_FBLAS(handle,blas.ssyr2k,ssyr2k);
	LOAD_FBLAS(handle,blas.ssyrk,ssyrk);
	LOAD_FBLAS(handle,blas.stbmv,stbmv);
	LOAD_FBLAS(handle,blas.stbsv,stbsv);
	LOAD_FBLAS(handle,blas.stpmv,stpmv);
	LOAD_FBLAS(handle,blas.stpsv,stpsv);
	LOAD_FBLAS(handle,blas.strmm,strmm);
	LOAD_FBLAS(handle,blas.strmv,strmv);
	LOAD_FBLAS(handle,blas.strsm,strsm);
	LOAD_FBLAS(handle,blas.strsv,strsv);
	LOAD_FBLAS(handle,blas.zaxpy,zaxpy);
	LOAD_FBLAS(handle,blas.zcopy,zcopy);
	LOAD_FBLAS(handle,blas.zdotc,zdotc);
	LOAD_FBLAS(handle,blas.zdotu,zdotu);
	LOAD_FBLAS(handle,blas.zdrot,zdrot);
	LOAD_FBLAS(handle,blas.zdscal,zdscal);
	LOAD_FBLAS(handle,blas.zgbmv,zgbmv);
	LOAD_FBLAS(handle,blas.zgemm,zgemm);
	LOAD_FBLAS(handle,blas.zgemv,zgemv);
	LOAD_FBLAS(handle,blas.zgerc,zgerc);
	LOAD_FBLAS(handle,blas.zgeru,zgeru);
	LOAD_FBLAS(handle,blas.zhbmv,zhbmv);
	LOAD_FBLAS(handle,blas.zhemm,zhemm);
	LOAD_FBLAS(handle,blas.zhemv,zhemv);
	LOAD_FBLAS(handle,blas.zher,zher);
	LOAD_FBLAS(handle,blas.zher2,zher2);
	LOAD_FBLAS(handle,blas.zher2k,zher2k);
	LOAD_FBLAS(handle,blas.zherk,zherk);
	LOAD_FBLAS(handle,blas.zhpmv,zhpmv);
	LOAD_FBLAS(handle,blas.zhpr,zhpr);
	LOAD_FBLAS(handle,blas.zhpr2,zhpr2);
	LOAD_FBLAS(handle,blas.zrotg,zrotg);
	LOAD_FBLAS(handle,blas.zscal,zscal);
	LOAD_FBLAS(handle,blas.zswap,zswap);
	LOAD_FBLAS(handle,blas.zsymm,zsymm);
	LOAD_FBLAS(handle,blas.zsyr2k,zsyr2k);
	LOAD_FBLAS(handle,blas.zsyrk,zsyrk);
	LOAD_FBLAS(handle,blas.ztbmv,ztbmv);
	LOAD_FBLAS(handle,blas.ztbsv,ztbsv);
	LOAD_FBLAS(handle,blas.ztpmv,ztpmv);
	LOAD_FBLAS(handle,blas.ztpsv,ztpsv);
	LOAD_FBLAS(handle,blas.ztrmm,ztrmm);
	LOAD_FBLAS(handle,blas.ztrmv,ztrmv);
	LOAD_FBLAS(handle,blas.ztrsm,ztrsm);
	LOAD_FBLAS(handle,blas.ztrsv,ztrsv);
	if (_ifailed != (*failed))
		return 1;
	else
			return 0;
}

void caxpy_(blasint* n, float complex* ca, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.caxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.caxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "caxpy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.caxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void caxpy(blasint* n, float complex* ca, float complex* cx, blasint* incx, float complex* cy, blasint* incy) __attribute__((alias("caxpy_")));


void caxpy32_(int32_t* n, float complex* ca, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.caxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.caxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "caxpy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.caxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void caxpy32(int32_t* n, float complex* ca, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy) __attribute__((alias("caxpy32_")));


void caxpy64_(int64_t* n, float complex* ca, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.caxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.caxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of caxpy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "caxpy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.caxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.caxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void caxpy64(int64_t* n, float complex* ca, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy) __attribute__((alias("caxpy64_")));



void ccopy_(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ccopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ccopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ccopy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ccopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void ccopy(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy) __attribute__((alias("ccopy_")));


void ccopy32_(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ccopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ccopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ccopy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ccopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void ccopy32(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy) __attribute__((alias("ccopy32_")));


void ccopy64_(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ccopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ccopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ccopy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ccopy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.ccopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ccopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void ccopy64(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy) __attribute__((alias("ccopy64_")));



void cdotc_( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotc - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotc( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy) __attribute__((alias("cdotc_")));


void cdotc32_( float complex* returnvalue, int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotc32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotc32( float complex* returnvalue, int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy) __attribute__((alias("cdotc32_")));


void cdotc64_( float complex* returnvalue, int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotc64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotc64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotc64( float complex* returnvalue, int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy) __attribute__((alias("cdotc64_")));



void cdotu_( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotu - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotu( float complex* returnvalue, blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy) __attribute__((alias("cdotu_")));


void cdotu32_( float complex* returnvalue, int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotu32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotu32( float complex* returnvalue, int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy) __attribute__((alias("cdotu32_")));


void cdotu64_( float complex* returnvalue, int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy)
{
	double ts;
	float complex (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	void (*fn_intel) (float complex *ret, void* n, void* cx, void* incx, void* cy, void* incy);
	float complex ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
			current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cdotu64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cdotu64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
		current_backend->blas.cdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void cdotu64( float complex* returnvalue, int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy) __attribute__((alias("cdotu64_")));



void cgbmv_(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _kl32; int64_t _kl64; void* _pkl;
	int32_t _ku32; int64_t _ku64; void* _pku;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgbmv(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy) __attribute__((alias("cgbmv_")));


void cgbmv32_(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _kl64; void* _pkl;
	int64_t _ku64; void* _pku;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgbmv32(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy) __attribute__((alias("cgbmv32_")));


void cgbmv64_(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _kl32; void* _pkl;
	int32_t _ku32; void* _pku;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgbmv64(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy) __attribute__((alias("cgbmv64_")));



void cgemm_(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cgemm(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc) __attribute__((alias("cgemm_")));


void cgemm32_(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cgemm32(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc) __attribute__((alias("cgemm32_")));


void cgemm64_(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cgemm64(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc) __attribute__((alias("cgemm64_")));



void cgemv_(char* trans, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgemv(char* trans, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy) __attribute__((alias("cgemv_")));


void cgemv32_(char* trans, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgemv32(char* trans, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy) __attribute__((alias("cgemv32_")));


void cgemv64_(char* trans, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.cgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void cgemv64(char* trans, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy) __attribute__((alias("cgemv64_")));



void cgerc_(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgerc - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgerc(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda) __attribute__((alias("cgerc_")));


void cgerc32_(int32_t* m, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgerc32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgerc32(int32_t* m, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda) __attribute__((alias("cgerc32_")));


void cgerc64_(int64_t* m, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgerc64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgerc64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgerc64(int64_t* m, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda) __attribute__((alias("cgerc64_")));



void cgeru_(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgeru - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgeru(blasint* m, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda) __attribute__((alias("cgeru_")));


void cgeru32_(int32_t* m, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgeru32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgeru32(int32_t* m, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda) __attribute__((alias("cgeru32_")));


void cgeru64_(int64_t* m, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cgeru64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cgeru64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cgeru64(int64_t* m, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda) __attribute__((alias("cgeru64_")));



void chbmv_(char* uplo, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chbmv(char* uplo, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy) __attribute__((alias("chbmv_")));


void chbmv32_(char* uplo, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chbmv32(char* uplo, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy) __attribute__((alias("chbmv32_")));


void chbmv64_(char* uplo, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chbmv64(char* uplo, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy) __attribute__((alias("chbmv64_")));



void chemm_(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void chemm(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc) __attribute__((alias("chemm_")));


void chemm32_(char* side, char* uplo, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void chemm32(char* side, char* uplo, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc) __attribute__((alias("chemm32_")));


void chemm64_(char* side, char* uplo, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.chemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void chemm64(char* side, char* uplo, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc) __attribute__((alias("chemm64_")));



void chemv_(char* uplo, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chemv(char* uplo, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy) __attribute__((alias("chemv_")));


void chemv32_(char* uplo, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chemv32(char* uplo, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy) __attribute__((alias("chemv32_")));


void chemv64_(char* uplo, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chemv64(char* uplo, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy) __attribute__((alias("chemv64_")));



void cher_(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* a, blasint* lda) __attribute__((alias("cher_")));


void cher32_(char* uplo, int32_t* n, float* alpha, float complex* x, int32_t* incx, float complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher32(char* uplo, int32_t* n, float* alpha, float complex* x, int32_t* incx, float complex* a, int32_t* lda) __attribute__((alias("cher32_")));


void cher64_(char* uplo, int64_t* n, float* alpha, float complex* x, int64_t* incx, float complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.cher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher64(char* uplo, int64_t* n, float* alpha, float complex* x, int64_t* incx, float complex* a, int64_t* lda) __attribute__((alias("cher64_")));



void cher2_(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher2(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* a, blasint* lda) __attribute__((alias("cher2_")));


void cher232_(char* uplo, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher232(char* uplo, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* a, int32_t* lda) __attribute__((alias("cher232_")));


void cher264_(char* uplo, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher264 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.cher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void cher264(char* uplo, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* a, int64_t* lda) __attribute__((alias("cher264_")));



void cher2k_(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cher2k(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float* beta, float complex* c, blasint* ldc) __attribute__((alias("cher2k_")));


void cher2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cher2k32(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float* beta, float complex* c, int32_t* ldc) __attribute__((alias("cher2k32_")));


void cher2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cher2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cher2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cher2k64(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float* beta, float complex* c, int64_t* ldc) __attribute__((alias("cher2k64_")));



void cherk_(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float complex* a, blasint* lda, float* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cherk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cherk(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float complex* a, blasint* lda, float* beta, float complex* c, blasint* ldc) __attribute__((alias("cherk_")));


void cherk32_(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float complex* a, int32_t* lda, float* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cherk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cherk32(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float complex* a, int32_t* lda, float* beta, float complex* c, int32_t* ldc) __attribute__((alias("cherk32_")));


void cherk64_(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float complex* a, int64_t* lda, float* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cherk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cherk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.cherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void cherk64(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float complex* a, int64_t* lda, float* beta, float complex* c, int64_t* ldc) __attribute__((alias("cherk64_")));



void chpmv_(char* uplo, blasint* n, float complex* alpha, float complex* ap, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chpmv(char* uplo, blasint* n, float complex* alpha, float complex* ap, float complex* x, blasint* incx, float complex* beta, float complex* y, blasint* incy) __attribute__((alias("chpmv_")));


void chpmv32_(char* uplo, int32_t* n, float complex* alpha, float complex* ap, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chpmv32(char* uplo, int32_t* n, float complex* alpha, float complex* ap, float complex* x, int32_t* incx, float complex* beta, float complex* y, int32_t* incy) __attribute__((alias("chpmv32_")));


void chpmv64_(char* uplo, int64_t* n, float complex* alpha, float complex* ap, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.chpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void chpmv64(char* uplo, int64_t* n, float complex* alpha, float complex* ap, float complex* x, int64_t* incx, float complex* beta, float complex* y, int64_t* incy) __attribute__((alias("chpmv64_")));



void chpr_(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void chpr(char* uplo, blasint* n, float* alpha, float complex* x, blasint* incx, float complex* ap) __attribute__((alias("chpr_")));


void chpr32_(char* uplo, int32_t* n, float* alpha, float complex* x, int32_t* incx, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void chpr32(char* uplo, int32_t* n, float* alpha, float complex* x, int32_t* incx, float complex* ap) __attribute__((alias("chpr32_")));


void chpr64_(char* uplo, int64_t* n, float* alpha, float complex* x, int64_t* incx, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.chpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void chpr64(char* uplo, int64_t* n, float* alpha, float complex* x, int64_t* incx, float complex* ap) __attribute__((alias("chpr64_")));



void chpr2_(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void chpr2(char* uplo, blasint* n, float complex* alpha, float complex* x, blasint* incx, float complex* y, blasint* incy, float complex* ap) __attribute__((alias("chpr2_")));


void chpr232_(char* uplo, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void chpr232(char* uplo, int32_t* n, float complex* alpha, float complex* x, int32_t* incx, float complex* y, int32_t* incy, float complex* ap) __attribute__((alias("chpr232_")));


void chpr264_(char* uplo, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.chpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.chpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of chpr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "chpr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.chpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.chpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void chpr264(char* uplo, int64_t* n, float complex* alpha, float complex* x, int64_t* incx, float complex* y, int64_t* incy, float complex* ap) __attribute__((alias("chpr264_")));



void crotg_(float complex* ca, float complex* cb, float* c, float complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.crotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.crotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "crotg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.crotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void crotg(float complex* ca, float complex* cb, float* c, float complex* s) __attribute__((alias("crotg_")));


void crotg32_(float complex* ca, float complex* cb, float* c, float complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.crotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.crotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "crotg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.crotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void crotg32(float complex* ca, float complex* cb, float* c, float complex* s) __attribute__((alias("crotg32_")));


void crotg64_(float complex* ca, float complex* cb, float* c, float complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.crotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.crotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "crotg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.crotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.crotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void crotg64(float complex* ca, float complex* cb, float* c, float complex* s) __attribute__((alias("crotg64_")));



void cscal_(blasint* n, float complex* ca, float complex* cx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
			current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
		current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void cscal(blasint* n, float complex* ca, float complex* cx, blasint* incx) __attribute__((alias("cscal_")));


void cscal32_(int32_t* n, float complex* ca, float complex* cx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
			current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
		current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void cscal32(int32_t* n, float complex* ca, float complex* cx, int32_t* incx) __attribute__((alias("cscal32_")));


void cscal64_(int64_t* n, float complex* ca, float complex* cx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* ca, void* cx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
			current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) ca, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
		current_backend->blas.cscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) ca, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void cscal64(int64_t* n, float complex* ca, float complex* cx, int64_t* incx) __attribute__((alias("cscal64_")));



void csrot_(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csrot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void csrot(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy, float* c, float* s) __attribute__((alias("csrot_")));


void csrot32_(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csrot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void csrot32(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy, float* c, float* s) __attribute__((alias("csrot32_")));


void csrot64_(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csrot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csrot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.csrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void csrot64(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy, float* c, float* s) __attribute__((alias("csrot64_")));



void csscal_(blasint* n, float* sa, float complex* cx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* cx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
			current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
		current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void csscal(blasint* n, float* sa, float complex* cx, blasint* incx) __attribute__((alias("csscal_")));


void csscal32_(int32_t* n, float* sa, float complex* cx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* cx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
			current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
		current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void csscal32(int32_t* n, float* sa, float complex* cx, int32_t* incx) __attribute__((alias("csscal32_")));


void csscal64_(int64_t* n, float* sa, float complex* cx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* cx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
			current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) cx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
		current_backend->blas.csscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) cx, (void*) _pincx); 
	} 
	return;
}
void csscal64(int64_t* n, float* sa, float complex* cx, int64_t* incx) __attribute__((alias("csscal64_")));



void cswap_(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cswap - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void cswap(blasint* n, float complex* cx, blasint* incx, float complex* cy, blasint* incy) __attribute__((alias("cswap_")));


void cswap32_(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cswap32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void cswap32(int32_t* n, float complex* cx, int32_t* incx, float complex* cy, int32_t* incy) __attribute__((alias("cswap32_")));


void cswap64_(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.cswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
			current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.cswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of cswap64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "cswap64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
		current_backend->blas.cswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.cswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy); 
	} 
	return;
}
void cswap64(int64_t* n, float complex* cx, int64_t* incx, float complex* cy, int64_t* incy) __attribute__((alias("cswap64_")));



void csymm_(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csymm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csymm(char* side, char* uplo, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc) __attribute__((alias("csymm_")));


void csymm32_(char* side, char* uplo, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csymm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csymm32(char* side, char* uplo, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc) __attribute__((alias("csymm32_")));


void csymm64_(char* side, char* uplo, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csymm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csymm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csymm64(char* side, char* uplo, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc) __attribute__((alias("csymm64_")));



void csyr2k_(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyr2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyr2k(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb, float complex* beta, float complex* c, blasint* ldc) __attribute__((alias("csyr2k_")));


void csyr2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyr2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyr2k32(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb, float complex* beta, float complex* c, int32_t* ldc) __attribute__((alias("csyr2k32_")));


void csyr2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyr2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyr2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyr2k64(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb, float complex* beta, float complex* c, int64_t* ldc) __attribute__((alias("csyr2k64_")));



void csyrk_(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* beta, float complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyrk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyrk(char* uplo, char* trans, blasint* n, blasint* k, float complex* alpha, float complex* a, blasint* lda, float complex* beta, float complex* c, blasint* ldc) __attribute__((alias("csyrk_")));


void csyrk32_(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* beta, float complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyrk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyrk32(char* uplo, char* trans, int32_t* n, int32_t* k, float complex* alpha, float complex* a, int32_t* lda, float complex* beta, float complex* c, int32_t* ldc) __attribute__((alias("csyrk32_")));


void csyrk64_(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* beta, float complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.csyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.csyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of csyrk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "csyrk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.csyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.csyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void csyrk64(char* uplo, char* trans, int64_t* n, int64_t* k, float complex* alpha, float complex* a, int64_t* lda, float complex* beta, float complex* c, int64_t* ldc) __attribute__((alias("csyrk64_")));



void ctbmv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbmv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx) __attribute__((alias("ctbmv_")));


void ctbmv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float complex* a, int32_t* lda, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbmv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float complex* a, int32_t* lda, float complex* x, int32_t* incx) __attribute__((alias("ctbmv32_")));


void ctbmv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float complex* a, int64_t* lda, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbmv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float complex* a, int64_t* lda, float complex* x, int64_t* incx) __attribute__((alias("ctbmv64_")));



void ctbsv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbsv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float complex* a, blasint* lda, float complex* x, blasint* incx) __attribute__((alias("ctbsv_")));


void ctbsv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float complex* a, int32_t* lda, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbsv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float complex* a, int32_t* lda, float complex* x, int32_t* incx) __attribute__((alias("ctbsv32_")));


void ctbsv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float complex* a, int64_t* lda, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctbsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctbsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctbsv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float complex* a, int64_t* lda, float complex* x, int64_t* incx) __attribute__((alias("ctbsv64_")));



void ctpmv_(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpmv(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx) __attribute__((alias("ctpmv_")));


void ctpmv32_(char* uplo, char* trans, char* diag, int32_t* n, float complex* ap, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpmv32(char* uplo, char* trans, char* diag, int32_t* n, float complex* ap, float complex* x, int32_t* incx) __attribute__((alias("ctpmv32_")));


void ctpmv64_(char* uplo, char* trans, char* diag, int64_t* n, float complex* ap, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpmv64(char* uplo, char* trans, char* diag, int64_t* n, float complex* ap, float complex* x, int64_t* incx) __attribute__((alias("ctpmv64_")));



void ctpsv_(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpsv(char* uplo, char* trans, char* diag, blasint* n, float complex* ap, float complex* x, blasint* incx) __attribute__((alias("ctpsv_")));


void ctpsv32_(char* uplo, char* trans, char* diag, int32_t* n, float complex* ap, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpsv32(char* uplo, char* trans, char* diag, int32_t* n, float complex* ap, float complex* x, int32_t* incx) __attribute__((alias("ctpsv32_")));


void ctpsv64_(char* uplo, char* trans, char* diag, int64_t* n, float complex* ap, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctpsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctpsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ctpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctpsv64(char* uplo, char* trans, char* diag, int64_t* n, float complex* ap, float complex* x, int64_t* incx) __attribute__((alias("ctpsv64_")));



void ctrmm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrmm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb) __attribute__((alias("ctrmm_")));


void ctrmm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrmm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb) __attribute__((alias("ctrmm32_")));


void ctrmm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrmm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb) __attribute__((alias("ctrmm64_")));



void ctrmv_(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrmv(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx) __attribute__((alias("ctrmv_")));


void ctrmv32_(char* uplo, char* trans, char* diag, int32_t* n, float complex* a, int32_t* lda, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrmv32(char* uplo, char* trans, char* diag, int32_t* n, float complex* a, int32_t* lda, float complex* x, int32_t* incx) __attribute__((alias("ctrmv32_")));


void ctrmv64_(char* uplo, char* trans, char* diag, int64_t* n, float complex* a, int64_t* lda, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrmv64(char* uplo, char* trans, char* diag, int64_t* n, float complex* a, int64_t* lda, float complex* x, int64_t* incx) __attribute__((alias("ctrmv64_")));



void ctrsm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrsm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float complex* alpha, float complex* a, blasint* lda, float complex* b, blasint* ldb) __attribute__((alias("ctrsm_")));


void ctrsm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrsm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float complex* alpha, float complex* a, int32_t* lda, float complex* b, int32_t* ldb) __attribute__((alias("ctrsm32_")));


void ctrsm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ctrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ctrsm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float complex* alpha, float complex* a, int64_t* lda, float complex* b, int64_t* ldb) __attribute__((alias("ctrsm64_")));



void ctrsv_(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrsv(char* uplo, char* trans, char* diag, blasint* n, float complex* a, blasint* lda, float complex* x, blasint* incx) __attribute__((alias("ctrsv_")));


void ctrsv32_(char* uplo, char* trans, char* diag, int32_t* n, float complex* a, int32_t* lda, float complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrsv32(char* uplo, char* trans, char* diag, int32_t* n, float complex* a, int32_t* lda, float complex* x, int32_t* incx) __attribute__((alias("ctrsv32_")));


void ctrsv64_(char* uplo, char* trans, char* diag, int64_t* n, float complex* a, int64_t* lda, float complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ctrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ctrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ctrsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ctrsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ctrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ctrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ctrsv64(char* uplo, char* trans, char* diag, int64_t* n, float complex* a, int64_t* lda, float complex* x, int64_t* incx) __attribute__((alias("ctrsv64_")));



double dasum_(blasint* n, double* dx, blasint* incx)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dasum the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dasum the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dasum - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
double dasum(blasint* n, double* dx, blasint* incx) __attribute__((alias("dasum_")));


double dasum32_(int32_t* n, double* dx, int32_t* incx)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dasum32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
double dasum32(int32_t* n, double* dx, int32_t* incx) __attribute__((alias("dasum32_")));


double dasum64_(int64_t* n, double* dx, int64_t* incx)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dasum64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dasum64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dasum64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.dasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
double dasum64(int64_t* n, double* dx, int64_t* incx) __attribute__((alias("dasum64_")));



void daxpy_(blasint* n, double* da, double* dx, blasint* incx, double* dy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.daxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.daxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "daxpy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.daxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void daxpy(blasint* n, double* da, double* dx, blasint* incx, double* dy, blasint* incy) __attribute__((alias("daxpy_")));


void daxpy32_(int32_t* n, double* da, double* dx, int32_t* incx, double* dy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.daxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.daxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "daxpy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.daxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void daxpy32(int32_t* n, double* da, double* dx, int32_t* incx, double* dy, int32_t* incy) __attribute__((alias("daxpy32_")));


void daxpy64_(int64_t* n, double* da, double* dx, int64_t* incx, double* dy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.daxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.daxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of daxpy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "daxpy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.daxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.daxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void daxpy64(int64_t* n, double* da, double* dx, int64_t* incx, double* dy, int64_t* incy) __attribute__((alias("daxpy64_")));



void dcopy_(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dcopy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dcopy(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy) __attribute__((alias("dcopy_")));


void dcopy32_(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dcopy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dcopy32(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy) __attribute__((alias("dcopy32_")));


void dcopy64_(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dcopy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dcopy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dcopy64(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy) __attribute__((alias("dcopy64_")));



double ddot_(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ddot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ddot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ddot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ddot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return ret;
}
double ddot(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy) __attribute__((alias("ddot_")));


double ddot32_(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ddot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ddot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ddot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ddot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return ret;
}
double ddot32(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy) __attribute__((alias("ddot32_")));


double ddot64_(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy)
{
	double ts;
	double (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ddot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ddot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ddot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ddot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.ddot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ddot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return ret;
}
double ddot64(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy) __attribute__((alias("ddot64_")));



void dgbmv_(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _kl32; int64_t _kl64; void* _pkl;
	int32_t _ku32; int64_t _ku64; void* _pku;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgbmv(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy) __attribute__((alias("dgbmv_")));


void dgbmv32_(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _kl64; void* _pkl;
	int64_t _ku64; void* _pku;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgbmv32(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy) __attribute__((alias("dgbmv32_")));


void dgbmv64_(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _kl32; void* _pkl;
	int32_t _ku32; void* _pku;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgbmv64(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy) __attribute__((alias("dgbmv64_")));



void dgemm_(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dgemm(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc) __attribute__((alias("dgemm_")));


void dgemm32_(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dgemm32(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc) __attribute__((alias("dgemm32_")));


void dgemm64_(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dgemm64(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc) __attribute__((alias("dgemm64_")));



void dgemv_(char* trans, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgemv(char* trans, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy) __attribute__((alias("dgemv_")));


void dgemv32_(char* trans, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgemv32(char* trans, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy) __attribute__((alias("dgemv32_")));


void dgemv64_(char* trans, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dgemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dgemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dgemv64(char* trans, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy) __attribute__((alias("dgemv64_")));



void dger_(blasint* m, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dger - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dger(blasint* m, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda) __attribute__((alias("dger_")));


void dger32_(int32_t* m, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dger32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dger32(int32_t* m, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* a, int32_t* lda) __attribute__((alias("dger32_")));


void dger64_(int64_t* m, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dger64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dger64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dger64(int64_t* m, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* a, int64_t* lda) __attribute__((alias("dger64_")));



double dnrm2_(blasint* n, double* x, blasint* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dnrm2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dnrm2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dnrm2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dnrm2(blasint* n, double* x, blasint* incx) __attribute__((alias("dnrm2_")));


double dnrm232_(int32_t* n, double* x, int32_t* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dnrm232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dnrm232(int32_t* n, double* x, int32_t* incx) __attribute__((alias("dnrm232_")));


double dnrm264_(int64_t* n, double* x, int64_t* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dnrm264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dnrm264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dnrm264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dnrm264(int64_t* n, double* x, int64_t* incx) __attribute__((alias("dnrm264_")));



void drot_(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drot.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void drot(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* c, double* s) __attribute__((alias("drot_")));


void drot32_(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drot.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void drot32(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy, double* c, double* s) __attribute__((alias("drot32_")));


void drot64_(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* c, void* s);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drot.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.drot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void drot64(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy, double* c, double* s) __attribute__((alias("drot64_")));



void drotg_(double* da, double* db, double* c, double* s)
{
	double ts;
	void (*fn) (void* da, void* db, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
			current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotg.calls[0]++;
		} else { 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
		current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotg.calls[0]++;
	} else { 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
	} 
	return;
}
void drotg(double* da, double* db, double* c, double* s) __attribute__((alias("drotg_")));


void drotg32_(double* da, double* db, double* c, double* s)
{
	double ts;
	void (*fn) (void* da, void* db, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
			current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotg.calls[0]++;
		} else { 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
		current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotg.calls[0]++;
	} else { 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
	} 
	return;
}
void drotg32(double* da, double* db, double* c, double* s) __attribute__((alias("drotg32_")));


void drotg64_(double* da, double* db, double* c, double* s)
{
	double ts;
	void (*fn) (void* da, void* db, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
			current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotg.calls[0]++;
		} else { 
				fn((void*) da, (void*) db, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
		current_backend->blas.drotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotg.calls[0]++;
	} else { 
		fn((void*) da, (void*) db, (void*) c, (void*) s); 
	} 
	return;
}
void drotg64(double* da, double* db, double* c, double* s) __attribute__((alias("drotg64_")));



void drotm_(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* dparam)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
			current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
		current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
	} 
	return;
}
void drotm(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy, double* dparam) __attribute__((alias("drotm_")));


void drotm32_(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy, double* dparam)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
			current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
		current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
	} 
	return;
}
void drotm32(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy, double* dparam) __attribute__((alias("drotm32_")));


void drotm64_(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy, double* dparam)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy, void* dparam);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
			current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy, (void*) dparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of drotm64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
		current_backend->blas.drotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy, (void*) dparam); 
	} 
	return;
}
void drotm64(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy, double* dparam) __attribute__((alias("drotm64_")));



void drotmg_(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam)
{
	double ts;
	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
			current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotmg.calls[0]++;
		} else { 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotmg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotmg.calls[0]++;
	} else { 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
	} 
	return;
}
void drotmg(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam) __attribute__((alias("drotmg_")));


void drotmg32_(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam)
{
	double ts;
	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
			current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotmg.calls[0]++;
		} else { 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotmg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotmg.calls[0]++;
	} else { 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
	} 
	return;
}
void drotmg32(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam) __attribute__((alias("drotmg32_")));


void drotmg64_(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam)
{
	double ts;
	void (*fn) (void* dd1, void* dd2, void* dx1, void* dy1, void* dparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.drotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
			current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.drotmg.calls[0]++;
		} else { 
				fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "drotmg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
		current_backend->blas.drotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.drotmg.calls[0]++;
	} else { 
		fn((void*) dd1, (void*) dd2, (void*) dx1, (void*) dy1, (void*) dparam); 
	} 
	return;
}
void drotmg64(double* dd1, double* dd2, double* dx1, double* dy1, double* dparam) __attribute__((alias("drotmg64_")));



void dsbmv_(char* uplo, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsbmv(char* uplo, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy) __attribute__((alias("dsbmv_")));


void dsbmv32_(char* uplo, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsbmv32(char* uplo, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy) __attribute__((alias("dsbmv32_")));


void dsbmv64_(char* uplo, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsbmv64(char* uplo, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy) __attribute__((alias("dsbmv64_")));



void dscal_(blasint* n, double* da, double* dx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
			current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
		current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
	} 
	return;
}
void dscal(blasint* n, double* da, double* dx, blasint* incx) __attribute__((alias("dscal_")));


void dscal32_(int32_t* n, double* da, double* dx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
			current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
		current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
	} 
	return;
}
void dscal32(int32_t* n, double* da, double* dx, int32_t* incx) __attribute__((alias("dscal32_")));


void dscal64_(int64_t* n, double* da, double* dx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* dx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
			current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) dx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
		current_backend->blas.dscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) dx, (void*) _pincx); 
	} 
	return;
}
void dscal64(int64_t* n, double* da, double* dx, int64_t* incx) __attribute__((alias("dscal64_")));



double dsdot_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsdot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
double dsdot(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("dsdot_")));


double dsdot32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsdot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
double dsdot32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("dsdot32_")));


double dsdot64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	double (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsdot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsdot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.dsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
double dsdot64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("dsdot64_")));



void dspmv_(char* uplo, blasint* n, double* alpha, double* ap, double* x, blasint* incx, double* beta, double* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dspmv(char* uplo, blasint* n, double* alpha, double* ap, double* x, blasint* incx, double* beta, double* y, blasint* incy) __attribute__((alias("dspmv_")));


void dspmv32_(char* uplo, int32_t* n, double* alpha, double* ap, double* x, int32_t* incx, double* beta, double* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dspmv32(char* uplo, int32_t* n, double* alpha, double* ap, double* x, int32_t* incx, double* beta, double* y, int32_t* incy) __attribute__((alias("dspmv32_")));


void dspmv64_(char* uplo, int64_t* n, double* alpha, double* ap, double* x, int64_t* incx, double* beta, double* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dspmv64(char* uplo, int64_t* n, double* alpha, double* ap, double* x, int64_t* incx, double* beta, double* y, int64_t* incy) __attribute__((alias("dspmv64_")));



void dspr_(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void dspr(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* ap) __attribute__((alias("dspr_")));


void dspr32_(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void dspr32(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* ap) __attribute__((alias("dspr32_")));


void dspr64_(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.dspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void dspr64(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* ap) __attribute__((alias("dspr64_")));



void dspr2_(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void dspr2(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* ap) __attribute__((alias("dspr2_")));


void dspr232_(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void dspr232(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* ap) __attribute__((alias("dspr232_")));


void dspr264_(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dspr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dspr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.dspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void dspr264(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* ap) __attribute__((alias("dspr264_")));



void dswap_(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dswap - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dswap(blasint* n, double* dx, blasint* incx, double* dy, blasint* incy) __attribute__((alias("dswap_")));


void dswap32_(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dswap32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dswap32(int32_t* n, double* dx, int32_t* incx, double* dy, int32_t* incy) __attribute__((alias("dswap32_")));


void dswap64_(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* dx, void* incx, void* dy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
			current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) dx, (void*) incx, (void*) dy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dswap64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dswap64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
		current_backend->blas.dswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) dx, (void*) _pincx, (void*) dy, (void*) _pincy); 
	} 
	return;
}
void dswap64(int64_t* n, double* dx, int64_t* incx, double* dy, int64_t* incy) __attribute__((alias("dswap64_")));



void dsymm_(char* side, char* uplo, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsymm(char* side, char* uplo, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc) __attribute__((alias("dsymm_")));


void dsymm32_(char* side, char* uplo, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsymm32(char* side, char* uplo, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc) __attribute__((alias("dsymm32_")));


void dsymm64_(char* side, char* uplo, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsymm64(char* side, char* uplo, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc) __attribute__((alias("dsymm64_")));



void dsymv_(char* uplo, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsymv(char* uplo, blasint* n, double* alpha, double* a, blasint* lda, double* x, blasint* incx, double* beta, double* y, blasint* incy) __attribute__((alias("dsymv_")));


void dsymv32_(char* uplo, int32_t* n, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsymv32(char* uplo, int32_t* n, double* alpha, double* a, int32_t* lda, double* x, int32_t* incx, double* beta, double* y, int32_t* incy) __attribute__((alias("dsymv32_")));


void dsymv64_(char* uplo, int64_t* n, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsymv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsymv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.dsymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void dsymv64(char* uplo, int64_t* n, double* alpha, double* a, int64_t* lda, double* x, int64_t* incx, double* beta, double* y, int64_t* incy) __attribute__((alias("dsymv64_")));



void dsyr_(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* a, blasint* lda) __attribute__((alias("dsyr_")));


void dsyr32_(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr32(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* a, int32_t* lda) __attribute__((alias("dsyr32_")));


void dsyr64_(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr64(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* a, int64_t* lda) __attribute__((alias("dsyr64_")));



void dsyr2_(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr2(char* uplo, blasint* n, double* alpha, double* x, blasint* incx, double* y, blasint* incy, double* a, blasint* lda) __attribute__((alias("dsyr2_")));


void dsyr232_(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr232(char* uplo, int32_t* n, double* alpha, double* x, int32_t* incx, double* y, int32_t* incy, double* a, int32_t* lda) __attribute__((alias("dsyr232_")));


void dsyr264_(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr264 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.dsyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void dsyr264(char* uplo, int64_t* n, double* alpha, double* x, int64_t* incx, double* y, int64_t* incy, double* a, int64_t* lda) __attribute__((alias("dsyr264_")));



void dsyr2k_(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyr2k(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* b, blasint* ldb, double* beta, double* c, blasint* ldc) __attribute__((alias("dsyr2k_")));


void dsyr2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyr2k32(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb, double* beta, double* c, int32_t* ldc) __attribute__((alias("dsyr2k32_")));


void dsyr2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyr2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyr2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyr2k64(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb, double* beta, double* c, int64_t* ldc) __attribute__((alias("dsyr2k64_")));



void dsyrk_(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* beta, double* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyrk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyrk(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double* a, blasint* lda, double* beta, double* c, blasint* ldc) __attribute__((alias("dsyrk_")));


void dsyrk32_(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* beta, double* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyrk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyrk32(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double* a, int32_t* lda, double* beta, double* c, int32_t* ldc) __attribute__((alias("dsyrk32_")));


void dsyrk64_(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* beta, double* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dsyrk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dsyrk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.dsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void dsyrk64(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double* a, int64_t* lda, double* beta, double* c, int64_t* ldc) __attribute__((alias("dsyrk64_")));



void dtbmv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbmv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx) __attribute__((alias("dtbmv_")));


void dtbmv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double* a, int32_t* lda, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbmv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double* a, int32_t* lda, double* x, int32_t* incx) __attribute__((alias("dtbmv32_")));


void dtbmv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double* a, int64_t* lda, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbmv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double* a, int64_t* lda, double* x, int64_t* incx) __attribute__((alias("dtbmv64_")));



void dtbsv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbsv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double* a, blasint* lda, double* x, blasint* incx) __attribute__((alias("dtbsv_")));


void dtbsv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double* a, int32_t* lda, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbsv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double* a, int32_t* lda, double* x, int32_t* incx) __attribute__((alias("dtbsv32_")));


void dtbsv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double* a, int64_t* lda, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtbsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtbsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtbsv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double* a, int64_t* lda, double* x, int64_t* incx) __attribute__((alias("dtbsv64_")));



void dtpmv_(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpmv(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx) __attribute__((alias("dtpmv_")));


void dtpmv32_(char* uplo, char* trans, char* diag, int32_t* n, double* ap, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpmv32(char* uplo, char* trans, char* diag, int32_t* n, double* ap, double* x, int32_t* incx) __attribute__((alias("dtpmv32_")));


void dtpmv64_(char* uplo, char* trans, char* diag, int64_t* n, double* ap, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpmv64(char* uplo, char* trans, char* diag, int64_t* n, double* ap, double* x, int64_t* incx) __attribute__((alias("dtpmv64_")));



void dtpsv_(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpsv(char* uplo, char* trans, char* diag, blasint* n, double* ap, double* x, blasint* incx) __attribute__((alias("dtpsv_")));


void dtpsv32_(char* uplo, char* trans, char* diag, int32_t* n, double* ap, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpsv32(char* uplo, char* trans, char* diag, int32_t* n, double* ap, double* x, int32_t* incx) __attribute__((alias("dtpsv32_")));


void dtpsv64_(char* uplo, char* trans, char* diag, int64_t* n, double* ap, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtpsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtpsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.dtpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtpsv64(char* uplo, char* trans, char* diag, int64_t* n, double* ap, double* x, int64_t* incx) __attribute__((alias("dtpsv64_")));



void dtrmm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrmm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb) __attribute__((alias("dtrmm_")));


void dtrmm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrmm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb) __attribute__((alias("dtrmm32_")));


void dtrmm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrmm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb) __attribute__((alias("dtrmm64_")));



void dtrmv_(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrmv(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx) __attribute__((alias("dtrmv_")));


void dtrmv32_(char* uplo, char* trans, char* diag, int32_t* n, double* a, int32_t* lda, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrmv32(char* uplo, char* trans, char* diag, int32_t* n, double* a, int32_t* lda, double* x, int32_t* incx) __attribute__((alias("dtrmv32_")));


void dtrmv64_(char* uplo, char* trans, char* diag, int64_t* n, double* a, int64_t* lda, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrmv64(char* uplo, char* trans, char* diag, int64_t* n, double* a, int64_t* lda, double* x, int64_t* incx) __attribute__((alias("dtrmv64_")));



void dtrsm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrsm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double* alpha, double* a, blasint* lda, double* b, blasint* ldb) __attribute__((alias("dtrsm_")));


void dtrsm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrsm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double* alpha, double* a, int32_t* lda, double* b, int32_t* ldb) __attribute__((alias("dtrsm32_")));


void dtrsm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.dtrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void dtrsm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double* alpha, double* a, int64_t* lda, double* b, int64_t* ldb) __attribute__((alias("dtrsm64_")));



void dtrsv_(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrsv(char* uplo, char* trans, char* diag, blasint* n, double* a, blasint* lda, double* x, blasint* incx) __attribute__((alias("dtrsv_")));


void dtrsv32_(char* uplo, char* trans, char* diag, int32_t* n, double* a, int32_t* lda, double* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrsv32(char* uplo, char* trans, char* diag, int32_t* n, double* a, int32_t* lda, double* x, int32_t* incx) __attribute__((alias("dtrsv32_")));


void dtrsv64_(char* uplo, char* trans, char* diag, int64_t* n, double* a, int64_t* lda, double* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dtrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dtrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dtrsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dtrsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.dtrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dtrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void dtrsv64(char* uplo, char* trans, char* diag, int64_t* n, double* a, int64_t* lda, double* x, int64_t* incx) __attribute__((alias("dtrsv64_")));



double dzasum_(blasint* n, double complex* zx, blasint* incx)
{
	double ts;
	double (*fn) (void* n, void* zx, void* incx);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dzasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dzasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dzasum the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dzasum the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dzasum - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dzasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
double dzasum(blasint* n, double complex* zx, blasint* incx) __attribute__((alias("dzasum_")));


double dzasum32_(int32_t* n, double complex* zx, int32_t* incx)
{
	double ts;
	double (*fn) (void* n, void* zx, void* incx);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dzasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dzasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dzasum32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dzasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
double dzasum32(int32_t* n, double complex* zx, int32_t* incx) __attribute__((alias("dzasum32_")));


double dzasum64_(int64_t* n, double complex* zx, int64_t* incx)
{
	double ts;
	double (*fn) (void* n, void* zx, void* incx);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dzasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dzasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dzasum64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dzasum64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dzasum64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.dzasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dzasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
double dzasum64(int64_t* n, double complex* zx, int64_t* incx) __attribute__((alias("dzasum64_")));



double dznrm2_(blasint* n, double complex* x, blasint* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dznrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dznrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dznrm2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dznrm2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dznrm2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dznrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dznrm2(blasint* n, double complex* x, blasint* incx) __attribute__((alias("dznrm2_")));


double dznrm232_(int32_t* n, double complex* x, int32_t* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dznrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dznrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dznrm232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dznrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dznrm232(int32_t* n, double complex* x, int32_t* incx) __attribute__((alias("dznrm232_")));


double dznrm264_(int64_t* n, double complex* x, int64_t* incx)
{
	double ts;
	double (*fn) (void* n, void* x, void* incx);
	double ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.dznrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.dznrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dznrm264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of dznrm264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "dznrm264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.dznrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.dznrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
double dznrm264(int64_t* n, double complex* x, int64_t* incx) __attribute__((alias("dznrm264_")));



int icamax_(blasint* n, float complex* cx, blasint* incx)
{
	double ts;
	blasint (*fn) (void* n, void* cx, void* incx);
	blasint ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.icamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.icamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of icamax the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of icamax the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "icamax - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.icamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
int icamax(blasint* n, float complex* cx, blasint* incx) __attribute__((alias("icamax_")));


int icamax32_(int32_t* n, float complex* cx, int32_t* incx)
{
	double ts;
	int32_t (*fn) (void* n, void* cx, void* incx);
	int32_t ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.icamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.icamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "icamax32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.icamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
int icamax32(int32_t* n, float complex* cx, int32_t* incx) __attribute__((alias("icamax32_")));


int icamax64_(int64_t* n, float complex* cx, int64_t* incx)
{
	double ts;
	int64_t (*fn) (void* n, void* cx, void* incx);
	int64_t ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.icamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.icamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of icamax64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of icamax64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "icamax64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.icamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.icamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
int icamax64(int64_t* n, float complex* cx, int64_t* incx) __attribute__((alias("icamax64_")));



int idamax_(blasint* n, double* dx, blasint* incx)
{
	double ts;
	blasint (*fn) (void* n, void* dx, void* incx);
	blasint ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.idamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.idamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of idamax the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of idamax the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "idamax - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.idamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
int idamax(blasint* n, double* dx, blasint* incx) __attribute__((alias("idamax_")));


int idamax32_(int32_t* n, double* dx, int32_t* incx)
{
	double ts;
	int32_t (*fn) (void* n, void* dx, void* incx);
	int32_t ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.idamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.idamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "idamax32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.idamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
int idamax32(int32_t* n, double* dx, int32_t* incx) __attribute__((alias("idamax32_")));


int idamax64_(int64_t* n, double* dx, int64_t* incx)
{
	double ts;
	int64_t (*fn) (void* n, void* dx, void* incx);
	int64_t ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.idamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
			current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.idamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) dx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of idamax64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of idamax64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "idamax64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
		current_backend->blas.idamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.idamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) dx, (void*) _pincx); 
	} 
	return ret;
}
int idamax64(int64_t* n, double* dx, int64_t* incx) __attribute__((alias("idamax64_")));



int isamax_(blasint* n, float* sx, blasint* incx)
{
	double ts;
	blasint (*fn) (void* n, void* sx, void* incx);
	blasint ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.isamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.isamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of isamax the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of isamax the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "isamax - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.isamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
int isamax(blasint* n, float* sx, blasint* incx) __attribute__((alias("isamax_")));


int isamax32_(int32_t* n, float* sx, int32_t* incx)
{
	double ts;
	int32_t (*fn) (void* n, void* sx, void* incx);
	int32_t ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.isamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.isamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "isamax32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.isamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
int isamax32(int32_t* n, float* sx, int32_t* incx) __attribute__((alias("isamax32_")));


int isamax64_(int64_t* n, float* sx, int64_t* incx)
{
	double ts;
	int64_t (*fn) (void* n, void* sx, void* incx);
	int64_t ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.isamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.isamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of isamax64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of isamax64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "isamax64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.isamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.isamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
int isamax64(int64_t* n, float* sx, int64_t* incx) __attribute__((alias("isamax64_")));



int izamax_(blasint* n, double complex* zx, blasint* incx)
{
	double ts;
	blasint (*fn) (void* n, void* zx, void* incx);
	blasint ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.izamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.izamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of izamax the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of izamax the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "izamax - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.izamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
int izamax(blasint* n, double complex* zx, blasint* incx) __attribute__((alias("izamax_")));


int izamax32_(int32_t* n, double complex* zx, int32_t* incx)
{
	double ts;
	int32_t (*fn) (void* n, void* zx, void* incx);
	int32_t ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.izamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.izamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "izamax32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.izamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
int izamax32(int32_t* n, double complex* zx, int32_t* incx) __attribute__((alias("izamax32_")));


int izamax64_(int64_t* n, double complex* zx, int64_t* incx)
{
	double ts;
	int64_t (*fn) (void* n, void* zx, void* incx);
	int64_t ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.izamax.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
			current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.izamax.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) zx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of izamax64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of izamax64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "izamax64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
		current_backend->blas.izamax.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.izamax.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) zx, (void*) _pincx); 
	} 
	return ret;
}
int izamax64(int64_t* n, double complex* zx, int64_t* incx) __attribute__((alias("izamax64_")));



float sasum_(blasint* n, float* sx, blasint* incx)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sasum the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sasum the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sasum - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
float sasum(blasint* n, float* sx, blasint* incx) __attribute__((alias("sasum_")));


float sasum32_(int32_t* n, float* sx, int32_t* incx)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sasum32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
float sasum32(int32_t* n, float* sx, int32_t* incx) __attribute__((alias("sasum32_")));


float sasum64_(int64_t* n, float* sx, int64_t* incx)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
			current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sasum64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sasum64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sasum64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
		current_backend->blas.sasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx); 
	} 
	return ret;
}
float sasum64(int64_t* n, float* sx, int64_t* incx) __attribute__((alias("sasum64_")));



void saxpy_(blasint* n, float* sa, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.saxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.saxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "saxpy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.saxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void saxpy(blasint* n, float* sa, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("saxpy_")));


void saxpy32_(int32_t* n, float* sa, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.saxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.saxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "saxpy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.saxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void saxpy32(int32_t* n, float* sa, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("saxpy32_")));


void saxpy64_(int64_t* n, float* sa, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.saxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.saxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of saxpy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "saxpy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.saxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.saxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void saxpy64(int64_t* n, float* sa, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("saxpy64_")));



float scasum_(blasint* n, float complex* cx, blasint* incx)
{
	double ts;
	float (*fn) (void* n, void* cx, void* incx);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scasum the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scasum the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scasum - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
float scasum(blasint* n, float complex* cx, blasint* incx) __attribute__((alias("scasum_")));


float scasum32_(int32_t* n, float complex* cx, int32_t* incx)
{
	double ts;
	float (*fn) (void* n, void* cx, void* incx);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scasum32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
float scasum32(int32_t* n, float complex* cx, int32_t* incx) __attribute__((alias("scasum32_")));


float scasum64_(int64_t* n, float complex* cx, int64_t* incx)
{
	double ts;
	float (*fn) (void* n, void* cx, void* incx);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scasum.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
			current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scasum.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) cx, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scasum64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scasum64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scasum64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
		current_backend->blas.scasum.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scasum.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) cx, (void*) _pincx); 
	} 
	return ret;
}
float scasum64(int64_t* n, float complex* cx, int64_t* incx) __attribute__((alias("scasum64_")));



float scnrm2_(blasint* n, float complex* x, blasint* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scnrm2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scnrm2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scnrm2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float scnrm2(blasint* n, float complex* x, blasint* incx) __attribute__((alias("scnrm2_")));


float scnrm232_(int32_t* n, float complex* x, int32_t* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scnrm232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float scnrm232(int32_t* n, float complex* x, int32_t* incx) __attribute__((alias("scnrm232_")));


float scnrm264_(int64_t* n, float complex* x, int64_t* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scnrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scnrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scnrm264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scnrm264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scnrm264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.scnrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scnrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float scnrm264(int64_t* n, float complex* x, int64_t* incx) __attribute__((alias("scnrm264_")));



void scopy_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scopy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void scopy(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("scopy_")));


void scopy32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scopy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void scopy32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("scopy32_")));


void scopy64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.scopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.scopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of scopy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "scopy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.scopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.scopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void scopy64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("scopy64_")));



float sdot_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdot(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("sdot_")));


float sdot32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdot32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("sdot32_")));


float sdot64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	float (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdot64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("sdot64_")));



float sdsdot_(blasint* n, float* sb, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdsdot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdsdot(blasint* n, float* sb, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("sdsdot_")));


float sdsdot32_(int32_t* n, float* sb, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdsdot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdsdot32(int32_t* n, float* sb, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("sdsdot32_")));


float sdsdot64_(int64_t* n, float* sb, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	float (*fn) (void* n, void* sb, void* sx, void* incx, void* sy, void* incy);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sdsdot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sdsdot.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) sb, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sdsdot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sdsdot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sdsdot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sdsdot.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) sb, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return ret;
}
float sdsdot64(int64_t* n, float* sb, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("sdsdot64_")));



void sgbmv_(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _kl32; int64_t _kl64; void* _pkl;
	int32_t _ku32; int64_t _ku64; void* _pku;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgbmv(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy) __attribute__((alias("sgbmv_")));


void sgbmv32_(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _kl64; void* _pkl;
	int64_t _ku64; void* _pku;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgbmv32(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy) __attribute__((alias("sgbmv32_")));


void sgbmv64_(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _kl32; void* _pkl;
	int32_t _ku32; void* _pku;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgbmv64(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy) __attribute__((alias("sgbmv64_")));



void sgemm_(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void sgemm(char* transa, char* transb, blasint* m, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc) __attribute__((alias("sgemm_")));


void sgemm32_(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void sgemm32(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc) __attribute__((alias("sgemm32_")));


void sgemm64_(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.sgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void sgemm64(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc) __attribute__((alias("sgemm64_")));



void sgemv_(char* trans, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgemv(char* trans, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy) __attribute__((alias("sgemv_")));


void sgemv32_(char* trans, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgemv32(char* trans, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy) __attribute__((alias("sgemv32_")));


void sgemv64_(char* trans, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sgemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sgemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sgemv64(char* trans, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy) __attribute__((alias("sgemv64_")));



void sger_(blasint* m, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sger - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void sger(blasint* m, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda) __attribute__((alias("sger_")));


void sger32_(int32_t* m, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sger32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void sger32(int32_t* m, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* a, int32_t* lda) __attribute__((alias("sger32_")));


void sger64_(int64_t* m, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sger.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sger.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sger64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sger64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.sger.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sger.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void sger64(int64_t* m, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* a, int64_t* lda) __attribute__((alias("sger64_")));



float snrm2_(blasint* n, float* x, blasint* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.snrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.snrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of snrm2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of snrm2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "snrm2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.snrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float snrm2(blasint* n, float* x, blasint* incx) __attribute__((alias("snrm2_")));


float snrm232_(int32_t* n, float* x, int32_t* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.snrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.snrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "snrm232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.snrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float snrm232(int32_t* n, float* x, int32_t* incx) __attribute__((alias("snrm232_")));


float snrm264_(int64_t* n, float* x, int64_t* incx)
{
	double ts;
	float (*fn) (void* n, void* x, void* incx);
	float ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.snrm2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				ret = fn((void*) n, (void*) x, (void*) incx); 
			current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.snrm2.calls[0]++;
		} else { 
				ret = fn((void*) n, (void*) x, (void*) incx); 
		} 
		return ret;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of snrm264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of snrm264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "snrm264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
		current_backend->blas.snrm2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.snrm2.calls[0]++;
	} else { 
		ret = fn((void*) _pn, (void*) x, (void*) _pincx); 
	} 
	return ret;
}
float snrm264(int64_t* n, float* x, int64_t* incx) __attribute__((alias("snrm264_")));



void srot_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srot.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void srot(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* c, float* s) __attribute__((alias("srot_")));


void srot32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srot.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void srot32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy, float* c, float* s) __attribute__((alias("srot32_")));


void srot64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy, float* c, float* s)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* c, void* s);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srot.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.srot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void srot64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy, float* c, float* s) __attribute__((alias("srot64_")));



void srotg_(float* sa, float* sb, float* c, float* s)
{
	double ts;
	void (*fn) (void* sa, void* sb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
			current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotg.calls[0]++;
		} else { 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotg.calls[0]++;
	} else { 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
	} 
	return;
}
void srotg(float* sa, float* sb, float* c, float* s) __attribute__((alias("srotg_")));


void srotg32_(float* sa, float* sb, float* c, float* s)
{
	double ts;
	void (*fn) (void* sa, void* sb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
			current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotg.calls[0]++;
		} else { 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotg.calls[0]++;
	} else { 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
	} 
	return;
}
void srotg32(float* sa, float* sb, float* c, float* s) __attribute__((alias("srotg32_")));


void srotg64_(float* sa, float* sb, float* c, float* s)
{
	double ts;
	void (*fn) (void* sa, void* sb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
			current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotg.calls[0]++;
		} else { 
				fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
		current_backend->blas.srotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotg.calls[0]++;
	} else { 
		fn((void*) sa, (void*) sb, (void*) c, (void*) s); 
	} 
	return;
}
void srotg64(float* sa, float* sb, float* c, float* s) __attribute__((alias("srotg64_")));



void srotm_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* sparam)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
			current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
		current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
	} 
	return;
}
void srotm(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy, float* sparam) __attribute__((alias("srotm_")));


void srotm32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy, float* sparam)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
			current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
		current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
	} 
	return;
}
void srotm32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy, float* sparam) __attribute__((alias("srotm32_")));


void srotm64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy, float* sparam)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy, void* sparam);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
			current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotm.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy, (void*) sparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of srotm64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
		current_backend->blas.srotm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotm.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy, (void*) sparam); 
	} 
	return;
}
void srotm64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy, float* sparam) __attribute__((alias("srotm64_")));



void srotmg_(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam)
{
	double ts;
	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
			current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotmg.calls[0]++;
		} else { 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotmg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotmg.calls[0]++;
	} else { 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
	} 
	return;
}
void srotmg(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam) __attribute__((alias("srotmg_")));


void srotmg32_(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam)
{
	double ts;
	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
			current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotmg.calls[0]++;
		} else { 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotmg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotmg.calls[0]++;
	} else { 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
	} 
	return;
}
void srotmg32(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam) __attribute__((alias("srotmg32_")));


void srotmg64_(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam)
{
	double ts;
	void (*fn) (void* sd1, void* sd2, void* sx1, void* sy1, void* sparam);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.srotmg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
			current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.srotmg.calls[0]++;
		} else { 
				fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "srotmg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
		current_backend->blas.srotmg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.srotmg.calls[0]++;
	} else { 
		fn((void*) sd1, (void*) sd2, (void*) sx1, (void*) sy1, (void*) sparam); 
	} 
	return;
}
void srotmg64(float* sd1, float* sd2, float* sx1, float* sy1, float* sparam) __attribute__((alias("srotmg64_")));



void ssbmv_(char* uplo, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssbmv(char* uplo, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy) __attribute__((alias("ssbmv_")));


void ssbmv32_(char* uplo, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssbmv32(char* uplo, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy) __attribute__((alias("ssbmv32_")));


void ssbmv64_(char* uplo, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssbmv64(char* uplo, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy) __attribute__((alias("ssbmv64_")));



void sscal_(blasint* n, float* sa, float* sx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
			current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
		current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
	} 
	return;
}
void sscal(blasint* n, float* sa, float* sx, blasint* incx) __attribute__((alias("sscal_")));


void sscal32_(int32_t* n, float* sa, float* sx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
			current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
		current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
	} 
	return;
}
void sscal32(int32_t* n, float* sa, float* sx, int32_t* incx) __attribute__((alias("sscal32_")));


void sscal64_(int64_t* n, float* sa, float* sx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* sa, void* sx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
			current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) sa, (void*) sx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
		current_backend->blas.sscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sa, (void*) sx, (void*) _pincx); 
	} 
	return;
}
void sscal64(int64_t* n, float* sa, float* sx, int64_t* incx) __attribute__((alias("sscal64_")));



void sspmv_(char* uplo, blasint* n, float* alpha, float* ap, float* x, blasint* incx, float* beta, float* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sspmv(char* uplo, blasint* n, float* alpha, float* ap, float* x, blasint* incx, float* beta, float* y, blasint* incy) __attribute__((alias("sspmv_")));


void sspmv32_(char* uplo, int32_t* n, float* alpha, float* ap, float* x, int32_t* incx, float* beta, float* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sspmv32(char* uplo, int32_t* n, float* alpha, float* ap, float* x, int32_t* incx, float* beta, float* y, int32_t* incy) __attribute__((alias("sspmv32_")));


void sspmv64_(char* uplo, int64_t* n, float* alpha, float* ap, float* x, int64_t* incx, float* beta, float* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.sspmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void sspmv64(char* uplo, int64_t* n, float* alpha, float* ap, float* x, int64_t* incx, float* beta, float* y, int64_t* incy) __attribute__((alias("sspmv64_")));



void sspr_(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void sspr(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* ap) __attribute__((alias("sspr_")));


void sspr32_(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void sspr32(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* ap) __attribute__((alias("sspr32_")));


void sspr64_(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.sspr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void sspr64(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* ap) __attribute__((alias("sspr64_")));



void sspr2_(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void sspr2(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* ap) __attribute__((alias("sspr2_")));


void sspr232_(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void sspr232(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* ap) __attribute__((alias("sspr232_")));


void sspr264_(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sspr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sspr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sspr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sspr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.sspr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sspr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void sspr264(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* ap) __attribute__((alias("sspr264_")));



void sswap_(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sswap - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void sswap(blasint* n, float* sx, blasint* incx, float* sy, blasint* incy) __attribute__((alias("sswap_")));


void sswap32_(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sswap32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void sswap32(int32_t* n, float* sx, int32_t* incx, float* sy, int32_t* incy) __attribute__((alias("sswap32_")));


void sswap64_(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* sx, void* incx, void* sy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.sswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
			current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.sswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) sx, (void*) incx, (void*) sy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of sswap64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "sswap64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
		current_backend->blas.sswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.sswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) sx, (void*) _pincx, (void*) sy, (void*) _pincy); 
	} 
	return;
}
void sswap64(int64_t* n, float* sx, int64_t* incx, float* sy, int64_t* incy) __attribute__((alias("sswap64_")));



void ssymm_(char* side, char* uplo, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssymm(char* side, char* uplo, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc) __attribute__((alias("ssymm_")));


void ssymm32_(char* side, char* uplo, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssymm32(char* side, char* uplo, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc) __attribute__((alias("ssymm32_")));


void ssymm64_(char* side, char* uplo, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssymm64(char* side, char* uplo, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc) __attribute__((alias("ssymm64_")));



void ssymv_(char* uplo, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssymv(char* uplo, blasint* n, float* alpha, float* a, blasint* lda, float* x, blasint* incx, float* beta, float* y, blasint* incy) __attribute__((alias("ssymv_")));


void ssymv32_(char* uplo, int32_t* n, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssymv32(char* uplo, int32_t* n, float* alpha, float* a, int32_t* lda, float* x, int32_t* incx, float* beta, float* y, int32_t* incy) __attribute__((alias("ssymv32_")));


void ssymv64_(char* uplo, int64_t* n, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssymv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssymv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssymv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssymv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.ssymv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssymv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void ssymv64(char* uplo, int64_t* n, float* alpha, float* a, int64_t* lda, float* x, int64_t* incx, float* beta, float* y, int64_t* incy) __attribute__((alias("ssymv64_")));



void ssyr_(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* a, blasint* lda) __attribute__((alias("ssyr_")));


void ssyr32_(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr32(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* a, int32_t* lda) __attribute__((alias("ssyr32_")));


void ssyr64_(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr64(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* a, int64_t* lda) __attribute__((alias("ssyr64_")));



void ssyr2_(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr2(char* uplo, blasint* n, float* alpha, float* x, blasint* incx, float* y, blasint* incy, float* a, blasint* lda) __attribute__((alias("ssyr2_")));


void ssyr232_(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr232(char* uplo, int32_t* n, float* alpha, float* x, int32_t* incx, float* y, int32_t* incy, float* a, int32_t* lda) __attribute__((alias("ssyr232_")));


void ssyr264_(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr264 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.ssyr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void ssyr264(char* uplo, int64_t* n, float* alpha, float* x, int64_t* incx, float* y, int64_t* incy, float* a, int64_t* lda) __attribute__((alias("ssyr264_")));



void ssyr2k_(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyr2k(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* b, blasint* ldb, float* beta, float* c, blasint* ldc) __attribute__((alias("ssyr2k_")));


void ssyr2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyr2k32(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb, float* beta, float* c, int32_t* ldc) __attribute__((alias("ssyr2k32_")));


void ssyr2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyr2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyr2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyr2k64(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb, float* beta, float* c, int64_t* ldc) __attribute__((alias("ssyr2k64_")));



void ssyrk_(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* beta, float* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyrk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyrk(char* uplo, char* trans, blasint* n, blasint* k, float* alpha, float* a, blasint* lda, float* beta, float* c, blasint* ldc) __attribute__((alias("ssyrk_")));


void ssyrk32_(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* beta, float* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyrk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyrk32(char* uplo, char* trans, int32_t* n, int32_t* k, float* alpha, float* a, int32_t* lda, float* beta, float* c, int32_t* ldc) __attribute__((alias("ssyrk32_")));


void ssyrk64_(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* beta, float* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ssyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ssyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ssyrk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ssyrk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.ssyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ssyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void ssyrk64(char* uplo, char* trans, int64_t* n, int64_t* k, float* alpha, float* a, int64_t* lda, float* beta, float* c, int64_t* ldc) __attribute__((alias("ssyrk64_")));



void stbmv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbmv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx) __attribute__((alias("stbmv_")));


void stbmv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float* a, int32_t* lda, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbmv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float* a, int32_t* lda, float* x, int32_t* incx) __attribute__((alias("stbmv32_")));


void stbmv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float* a, int64_t* lda, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbmv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float* a, int64_t* lda, float* x, int64_t* incx) __attribute__((alias("stbmv64_")));



void stbsv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbsv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, float* a, blasint* lda, float* x, blasint* incx) __attribute__((alias("stbsv_")));


void stbsv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float* a, int32_t* lda, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbsv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, float* a, int32_t* lda, float* x, int32_t* incx) __attribute__((alias("stbsv32_")));


void stbsv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float* a, int64_t* lda, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stbsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stbsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.stbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stbsv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, float* a, int64_t* lda, float* x, int64_t* incx) __attribute__((alias("stbsv64_")));



void stpmv_(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpmv(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx) __attribute__((alias("stpmv_")));


void stpmv32_(char* uplo, char* trans, char* diag, int32_t* n, float* ap, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpmv32(char* uplo, char* trans, char* diag, int32_t* n, float* ap, float* x, int32_t* incx) __attribute__((alias("stpmv32_")));


void stpmv64_(char* uplo, char* trans, char* diag, int64_t* n, float* ap, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpmv64(char* uplo, char* trans, char* diag, int64_t* n, float* ap, float* x, int64_t* incx) __attribute__((alias("stpmv64_")));



void stpsv_(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpsv(char* uplo, char* trans, char* diag, blasint* n, float* ap, float* x, blasint* incx) __attribute__((alias("stpsv_")));


void stpsv32_(char* uplo, char* trans, char* diag, int32_t* n, float* ap, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpsv32(char* uplo, char* trans, char* diag, int32_t* n, float* ap, float* x, int32_t* incx) __attribute__((alias("stpsv32_")));


void stpsv64_(char* uplo, char* trans, char* diag, int64_t* n, float* ap, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.stpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.stpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of stpsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "stpsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.stpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.stpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void stpsv64(char* uplo, char* trans, char* diag, int64_t* n, float* ap, float* x, int64_t* incx) __attribute__((alias("stpsv64_")));



void strmm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strmm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb) __attribute__((alias("strmm_")));


void strmm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strmm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb) __attribute__((alias("strmm32_")));


void strmm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strmm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb) __attribute__((alias("strmm64_")));



void strmv_(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strmv(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx) __attribute__((alias("strmv_")));


void strmv32_(char* uplo, char* trans, char* diag, int32_t* n, float* a, int32_t* lda, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strmv32(char* uplo, char* trans, char* diag, int32_t* n, float* a, int32_t* lda, float* x, int32_t* incx) __attribute__((alias("strmv32_")));


void strmv64_(char* uplo, char* trans, char* diag, int64_t* n, float* a, int64_t* lda, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strmv64(char* uplo, char* trans, char* diag, int64_t* n, float* a, int64_t* lda, float* x, int64_t* incx) __attribute__((alias("strmv64_")));



void strsm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strsm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, float* alpha, float* a, blasint* lda, float* b, blasint* ldb) __attribute__((alias("strsm_")));


void strsm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strsm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, float* alpha, float* a, int32_t* lda, float* b, int32_t* ldb) __attribute__((alias("strsm32_")));


void strsm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.strsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void strsm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, float* alpha, float* a, int64_t* lda, float* b, int64_t* ldb) __attribute__((alias("strsm64_")));



void strsv_(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strsv(char* uplo, char* trans, char* diag, blasint* n, float* a, blasint* lda, float* x, blasint* incx) __attribute__((alias("strsv_")));


void strsv32_(char* uplo, char* trans, char* diag, int32_t* n, float* a, int32_t* lda, float* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strsv32(char* uplo, char* trans, char* diag, int32_t* n, float* a, int32_t* lda, float* x, int32_t* incx) __attribute__((alias("strsv32_")));


void strsv64_(char* uplo, char* trans, char* diag, int64_t* n, float* a, int64_t* lda, float* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.strsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.strsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of strsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "strsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.strsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.strsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void strsv64(char* uplo, char* trans, char* diag, int64_t* n, float* a, int64_t* lda, float* x, int64_t* incx) __attribute__((alias("strsv64_")));



void zaxpy_(blasint* n, double complex* za, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zaxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zaxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zaxpy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zaxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zaxpy(blasint* n, double complex* za, double complex* zx, blasint* incx, double complex* zy, blasint* incy) __attribute__((alias("zaxpy_")));


void zaxpy32_(int32_t* n, double complex* za, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zaxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zaxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zaxpy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zaxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zaxpy32(int32_t* n, double complex* za, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy) __attribute__((alias("zaxpy32_")));


void zaxpy64_(int64_t* n, double complex* za, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zaxpy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zaxpy.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zaxpy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zaxpy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zaxpy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zaxpy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zaxpy64(int64_t* n, double complex* za, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy) __attribute__((alias("zaxpy64_")));



void zcopy_(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zcopy - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zcopy(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy) __attribute__((alias("zcopy_")));


void zcopy32_(int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zcopy32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zcopy32(int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy) __attribute__((alias("zcopy32_")));


void zcopy64_(int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zcopy.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zcopy.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zcopy64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zcopy64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zcopy.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zcopy.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zcopy64(int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy) __attribute__((alias("zcopy64_")));



void zdotc_( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotc - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotc( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy) __attribute__((alias("zdotc_")));


void zdotc32_( double complex* returnvalue, int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotc32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotc32( double complex* returnvalue, int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy) __attribute__((alias("zdotc32_")));


void zdotc64_( double complex* returnvalue, int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotc.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotc.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotc64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotc64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotc.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotc64( double complex* returnvalue, int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy) __attribute__((alias("zdotc64_")));



void zdotu_( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotu - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotu( double complex* returnvalue, blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy) __attribute__((alias("zdotu_")));


void zdotu32_( double complex* returnvalue, int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotu32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotu32( double complex* returnvalue, int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy) __attribute__((alias("zdotu32_")));


void zdotu64_( double complex* returnvalue, int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy)
{
	double ts;
	double complex (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	void (*fn_intel) (double complex *ret, void* n, void* zx, void* incx, void* zy, void* incy);
	double complex ret;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdotu.call_fblas; 
	fn_intel = (void *) fn;
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
			current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdotu.calls[0]++;
		} else { 
			if(current_backend->info.intel_interface == 0 ) {
				ret = fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			} else {
				fn_intel( &ret, (void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy);
			}
		} 
		*returnvalue = ret; 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdotu64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdotu64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
		current_backend->blas.zdotu.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdotu.calls[0]++;
	} else { 
		if(current_backend->info.intel_interface == 0 ) {
			ret = fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		} else {
			fn_intel( &ret, (void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy);
		}
	} 
	 *returnvalue = ret; 
	return;
}
void zdotu64( double complex* returnvalue, int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy) __attribute__((alias("zdotu64_")));



void zdrot_(blasint* n, double complex* cx, blasint* incx, double complex* cy, blasint* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdrot - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void zdrot(blasint* n, double complex* cx, blasint* incx, double complex* cy, blasint* incy, double* c, double* s) __attribute__((alias("zdrot_")));


void zdrot32_(int32_t* n, double complex* cx, int32_t* incx, double complex* cy, int32_t* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdrot32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void zdrot32(int32_t* n, double complex* cx, int32_t* incx, double complex* cy, int32_t* incy, double* c, double* s) __attribute__((alias("zdrot32_")));


void zdrot64_(int64_t* n, double complex* cx, int64_t* incx, double complex* cy, int64_t* incy, double* c, double* s)
{
	double ts;
	void (*fn) (void* n, void* cx, void* incx, void* cy, void* incy, void* c, void* s);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdrot.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
			current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdrot.calls[0]++;
		} else { 
				fn((void*) n, (void*) cx, (void*) incx, (void*) cy, (void*) incy, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdrot64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdrot64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
		current_backend->blas.zdrot.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdrot.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) cx, (void*) _pincx, (void*) cy, (void*) _pincy, (void*) c, (void*) s); 
	} 
	return;
}
void zdrot64(int64_t* n, double complex* cx, int64_t* incx, double complex* cy, int64_t* incy, double* c, double* s) __attribute__((alias("zdrot64_")));



void zdscal_(blasint* n, double* da, double complex* zx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* zx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
			current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
		current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zdscal(blasint* n, double* da, double complex* zx, blasint* incx) __attribute__((alias("zdscal_")));


void zdscal32_(int32_t* n, double* da, double complex* zx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* zx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
			current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
		current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zdscal32(int32_t* n, double* da, double complex* zx, int32_t* incx) __attribute__((alias("zdscal32_")));


void zdscal64_(int64_t* n, double* da, double complex* zx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* da, void* zx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zdscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
			current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zdscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) da, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zdscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zdscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
		current_backend->blas.zdscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zdscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) da, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zdscal64(int64_t* n, double* da, double complex* zx, int64_t* incx) __attribute__((alias("zdscal64_")));



void zgbmv_(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _kl32; int64_t _kl64; void* _pkl;
	int32_t _ku32; int64_t _ku64; void* _pku;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgbmv(char* trans, blasint* m, blasint* n, blasint* kl, blasint* ku, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy) __attribute__((alias("zgbmv_")));


void zgbmv32_(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _kl64; void* _pkl;
	int64_t _ku64; void* _pku;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_kl64 = (int64_t)*kl;
		_pkl = &_kl64;
		_ku64 = (int64_t)*ku;
		_pku = &_ku64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgbmv32(char* trans, int32_t* m, int32_t* n, int32_t* kl, int32_t* ku, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy) __attribute__((alias("zgbmv32_")));


void zgbmv64_(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* kl, void* ku, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _kl32; void* _pkl;
	int32_t _ku32; void* _pku;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgbmv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) kl, (void*) ku, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *kl > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter kl is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ku > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter ku is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_kl32 = (int32_t) *kl;
		_pkl = &_kl32;
		_ku32 = (int32_t) *ku;
		_pku = &_ku32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgbmv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) _pkl, (void*) _pku, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgbmv64(char* trans, int64_t* m, int64_t* n, int64_t* kl, int64_t* ku, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy) __attribute__((alias("zgbmv64_")));



void zgemm_(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zgemm(char* transa, char* transb, blasint* m, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc) __attribute__((alias("zgemm_")));


void zgemm32_(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zgemm32(char* transa, char* transb, int32_t* m, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc) __attribute__((alias("zgemm32_")));


void zgemm64_(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* transa, void* transb, void* m, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemm.calls[0]++;
		} else { 
				fn((void*) transa, (void*) transb, (void*) m, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zgemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemm.calls[0]++;
	} else { 
		fn((void*) transa, (void*) transb, (void*) _pm, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zgemm64(char* transa, char* transb, int64_t* m, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc) __attribute__((alias("zgemm64_")));



void zgemv_(char* trans, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgemv(char* trans, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy) __attribute__((alias("zgemv_")));


void zgemv32_(char* trans, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgemv32(char* trans, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy) __attribute__((alias("zgemv32_")));


void zgemv64_(char* trans, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* trans, void* m, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgemv.calls[0]++;
		} else { 
				fn((void*) trans, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zgemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgemv.calls[0]++;
	} else { 
		fn((void*) trans, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zgemv64(char* trans, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy) __attribute__((alias("zgemv64_")));



void zgerc_(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgerc - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgerc(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda) __attribute__((alias("zgerc_")));


void zgerc32_(int32_t* m, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgerc32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgerc32(int32_t* m, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda) __attribute__((alias("zgerc32_")));


void zgerc64_(int64_t* m, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgerc.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgerc.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgerc64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgerc64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgerc.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgerc.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgerc64(int64_t* m, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda) __attribute__((alias("zgerc64_")));



void zgeru_(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgeru - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgeru(blasint* m, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda) __attribute__((alias("zgeru_")));


void zgeru32_(int32_t* m, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgeru32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgeru32(int32_t* m, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda) __attribute__((alias("zgeru32_")));


void zgeru64_(int64_t* m, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* m, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zgeru.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zgeru.calls[0]++;
		} else { 
				fn((void*) m, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zgeru64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zgeru64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zgeru.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zgeru.calls[0]++;
	} else { 
		fn((void*) _pm, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zgeru64(int64_t* m, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda) __attribute__((alias("zgeru64_")));



void zhbmv_(char* uplo, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhbmv(char* uplo, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy) __attribute__((alias("zhbmv_")));


void zhbmv32_(char* uplo, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhbmv32(char* uplo, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy) __attribute__((alias("zhbmv32_")));


void zhbmv64_(char* uplo, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* k, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhbmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhbmv64(char* uplo, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy) __attribute__((alias("zhbmv64_")));



void zhemm_(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zhemm(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc) __attribute__((alias("zhemm_")));


void zhemm32_(char* side, char* uplo, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zhemm32(char* side, char* uplo, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc) __attribute__((alias("zhemm32_")));


void zhemm64_(char* side, char* uplo, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zhemm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zhemm64(char* side, char* uplo, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc) __attribute__((alias("zhemm64_")));



void zhemv_(char* uplo, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhemv(char* uplo, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy) __attribute__((alias("zhemv_")));


void zhemv32_(char* uplo, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhemv32(char* uplo, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy) __attribute__((alias("zhemv32_")));


void zhemv64_(char* uplo, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* a, void* lda, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhemv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhemv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhemv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhemv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhemv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhemv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhemv64(char* uplo, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy) __attribute__((alias("zhemv64_")));



void zher_(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* a, blasint* lda) __attribute__((alias("zher_")));


void zher32_(char* uplo, int32_t* n, double* alpha, double complex* x, int32_t* incx, double complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher32(char* uplo, int32_t* n, double* alpha, double complex* x, int32_t* incx, double complex* a, int32_t* lda) __attribute__((alias("zher32_")));


void zher64_(char* uplo, int64_t* n, double* alpha, double complex* x, int64_t* incx, double complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
			current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
		current_backend->blas.zher.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher64(char* uplo, int64_t* n, double* alpha, double complex* x, int64_t* incx, double complex* a, int64_t* lda) __attribute__((alias("zher64_")));



void zher2_(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	int32_t _lda32; int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher2(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* a, blasint* lda) __attribute__((alias("zher2_")));


void zher232_(char* uplo, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	int64_t _lda64; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher232(char* uplo, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* a, int32_t* lda) __attribute__((alias("zher232_")));


void zher264_(char* uplo, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* a, void* lda);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	int32_t _lda32; void* _plda;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
			current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) a, (void*) lda); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher264 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
		current_backend->blas.zher2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) a, (void*) _plda); 
	} 
	return;
}
void zher264(char* uplo, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* a, int64_t* lda) __attribute__((alias("zher264_")));



void zher2k_(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zher2k(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double* beta, double complex* c, blasint* ldc) __attribute__((alias("zher2k_")));


void zher2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zher2k32(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double* beta, double complex* c, int32_t* ldc) __attribute__((alias("zher2k32_")));


void zher2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zher2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zher2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zher2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zher2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zher2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zher2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zher2k64(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double* beta, double complex* c, int64_t* ldc) __attribute__((alias("zher2k64_")));



void zherk_(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double complex* a, blasint* lda, double* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zherk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zherk(char* uplo, char* trans, blasint* n, blasint* k, double* alpha, double complex* a, blasint* lda, double* beta, double complex* c, blasint* ldc) __attribute__((alias("zherk_")));


void zherk32_(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double complex* a, int32_t* lda, double* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zherk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zherk32(char* uplo, char* trans, int32_t* n, int32_t* k, double* alpha, double complex* a, int32_t* lda, double* beta, double complex* c, int32_t* ldc) __attribute__((alias("zherk32_")));


void zherk64_(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double complex* a, int64_t* lda, double* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zherk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zherk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zherk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zherk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zherk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zherk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zherk64(char* uplo, char* trans, int64_t* n, int64_t* k, double* alpha, double complex* a, int64_t* lda, double* beta, double complex* c, int64_t* ldc) __attribute__((alias("zherk64_")));



void zhpmv_(char* uplo, blasint* n, double complex* alpha, double complex* ap, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhpmv(char* uplo, blasint* n, double complex* alpha, double complex* ap, double complex* x, blasint* incx, double complex* beta, double complex* y, blasint* incy) __attribute__((alias("zhpmv_")));


void zhpmv32_(char* uplo, int32_t* n, double complex* alpha, double complex* ap, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhpmv32(char* uplo, int32_t* n, double complex* alpha, double complex* ap, double complex* x, int32_t* incx, double complex* beta, double complex* y, int32_t* incy) __attribute__((alias("zhpmv32_")));


void zhpmv64_(char* uplo, int64_t* n, double complex* alpha, double complex* ap, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* ap, void* x, void* incx, void* beta, void* y, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
			current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) ap, (void*) x, (void*) incx, (void*) beta, (void*) y, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpmv64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
		current_backend->blas.zhpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) ap, (void*) x, (void*) _pincx, (void*) beta, (void*) y, (void*) _pincy); 
	} 
	return;
}
void zhpmv64(char* uplo, int64_t* n, double complex* alpha, double complex* ap, double complex* x, int64_t* incx, double complex* beta, double complex* y, int64_t* incy) __attribute__((alias("zhpmv64_")));



void zhpr_(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void zhpr(char* uplo, blasint* n, double* alpha, double complex* x, blasint* incx, double complex* ap) __attribute__((alias("zhpr_")));


void zhpr32_(char* uplo, int32_t* n, double* alpha, double complex* x, int32_t* incx, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void zhpr32(char* uplo, int32_t* n, double* alpha, double complex* x, int32_t* incx, double complex* ap) __attribute__((alias("zhpr32_")));


void zhpr64_(char* uplo, int64_t* n, double* alpha, double complex* x, int64_t* incx, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
			current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
		current_backend->blas.zhpr.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) ap); 
	} 
	return;
}
void zhpr64(char* uplo, int64_t* n, double* alpha, double complex* x, int64_t* incx, double complex* ap) __attribute__((alias("zhpr64_")));



void zhpr2_(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr2 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr2 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr2 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr2 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void zhpr2(char* uplo, blasint* n, double complex* alpha, double complex* x, blasint* incx, double complex* y, blasint* incy, double complex* ap) __attribute__((alias("zhpr2_")));


void zhpr232_(char* uplo, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr232 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void zhpr232(char* uplo, int32_t* n, double complex* alpha, double complex* x, int32_t* incx, double complex* y, int32_t* incy, double complex* ap) __attribute__((alias("zhpr232_")));


void zhpr264_(char* uplo, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* ap)
{
	double ts;
	void (*fn) (void* uplo, void* n, void* alpha, void* x, void* incx, void* y, void* incy, void* ap);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zhpr2.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
			current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zhpr2.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) n, (void*) alpha, (void*) x, (void*) incx, (void*) y, (void*) incy, (void*) ap); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr264 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr264 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zhpr264 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zhpr264 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
		current_backend->blas.zhpr2.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zhpr2.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) _pn, (void*) alpha, (void*) x, (void*) _pincx, (void*) y, (void*) _pincy, (void*) ap); 
	} 
	return;
}
void zhpr264(char* uplo, int64_t* n, double complex* alpha, double complex* x, int64_t* incx, double complex* y, int64_t* incy, double complex* ap) __attribute__((alias("zhpr264_")));



void zrotg_(double complex* ca, double complex* cb, double* c, double complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zrotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zrotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
		}
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zrotg - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zrotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void zrotg(double complex* ca, double complex* cb, double* c, double complex* s) __attribute__((alias("zrotg_")));


void zrotg32_(double complex* ca, double complex* cb, double* c, double complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zrotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zrotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zrotg32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zrotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void zrotg32(double complex* ca, double complex* cb, double* c, double complex* s) __attribute__((alias("zrotg32_")));


void zrotg64_(double complex* ca, double complex* cb, double* c, double complex* s)
{
	double ts;
	void (*fn) (void* ca, void* cb, void* c, void* s);
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zrotg.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
			current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zrotg.calls[0]++;
		} else { 
				fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
		}
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zrotg64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
		current_backend->blas.zrotg.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zrotg.calls[0]++;
	} else { 
		fn((void*) ca, (void*) cb, (void*) c, (void*) s); 
	} 
	return;
}
void zrotg64(double complex* ca, double complex* cb, double* c, double complex* s) __attribute__((alias("zrotg64_")));



void zscal_(blasint* n, double complex* za, double complex* zx, blasint* incx)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
			current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zscal the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zscal the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zscal - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
		current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zscal(blasint* n, double complex* za, double complex* zx, blasint* incx) __attribute__((alias("zscal_")));


void zscal32_(int32_t* n, double complex* za, double complex* zx, int32_t* incx)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
			current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zscal32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
		current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zscal32(int32_t* n, double complex* za, double complex* zx, int32_t* incx) __attribute__((alias("zscal32_")));


void zscal64_(int64_t* n, double complex* za, double complex* zx, int64_t* incx)
{
	double ts;
	void (*fn) (void* n, void* za, void* zx, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zscal.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
			current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zscal.calls[0]++;
		} else { 
				fn((void*) n, (void*) za, (void*) zx, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zscal64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zscal64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zscal64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
		current_backend->blas.zscal.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zscal.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) za, (void*) zx, (void*) _pincx); 
	} 
	return;
}
void zscal64(int64_t* n, double complex* za, double complex* zx, int64_t* incx) __attribute__((alias("zscal64_")));



void zswap_(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	int32_t _incy32; int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zswap - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zswap(blasint* n, double complex* zx, blasint* incx, double complex* zy, blasint* incy) __attribute__((alias("zswap_")));


void zswap32_(int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	int64_t _incy64; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
		_incy64 = (int64_t)*incy;
		_pincy = &_incy64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zswap32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zswap32(int32_t* n, double complex* zx, int32_t* incx, double complex* zy, int32_t* incy) __attribute__((alias("zswap32_")));


void zswap64_(int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy)
{
	double ts;
	void (*fn) (void* n, void* zx, void* incx, void* zy, void* incy);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	int32_t _incy32; void* _pincy;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zswap.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
			current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zswap.calls[0]++;
		} else { 
				fn((void*) n, (void*) zx, (void*) incx, (void*) zy, (void*) incy); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incy > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zswap64 the parameter incy is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
		_incy32 = (int32_t) *incy;
		_pincy = &_incy32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zswap64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
		current_backend->blas.zswap.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zswap.calls[0]++;
	} else { 
		fn((void*) _pn, (void*) zx, (void*) _pincx, (void*) zy, (void*) _pincy); 
	} 
	return;
}
void zswap64(int64_t* n, double complex* zx, int64_t* incx, double complex* zy, int64_t* incy) __attribute__((alias("zswap64_")));



void zsymm_(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsymm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsymm(char* side, char* uplo, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc) __attribute__((alias("zsymm_")));


void zsymm32_(char* side, char* uplo, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsymm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsymm32(char* side, char* uplo, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc) __attribute__((alias("zsymm32_")));


void zsymm64_(char* side, char* uplo, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsymm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsymm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsymm64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsymm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsymm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsymm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsymm64(char* side, char* uplo, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc) __attribute__((alias("zsymm64_")));



void zsyr2k_(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyr2k - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyr2k(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb, double complex* beta, double complex* c, blasint* ldc) __attribute__((alias("zsyr2k_")));


void zsyr2k32_(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyr2k32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyr2k32(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb, double complex* beta, double complex* c, int32_t* ldc) __attribute__((alias("zsyr2k32_")));


void zsyr2k64_(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* b, void* ldb, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyr2k.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyr2k.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyr2k64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyr2k64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyr2k.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyr2k.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyr2k64(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb, double complex* beta, double complex* c, int64_t* ldc) __attribute__((alias("zsyr2k64_")));



void zsyrk_(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* beta, double complex* c, blasint* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldc32; int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyrk - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyrk(char* uplo, char* trans, blasint* n, blasint* k, double complex* alpha, double complex* a, blasint* lda, double complex* beta, double complex* c, blasint* ldc) __attribute__((alias("zsyrk_")));


void zsyrk32_(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* beta, double complex* c, int32_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _ldc64; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldc64 = (int64_t)*ldc;
		_pldc = &_ldc64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyrk32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyrk32(char* uplo, char* trans, int32_t* n, int32_t* k, double complex* alpha, double complex* a, int32_t* lda, double complex* beta, double complex* c, int32_t* ldc) __attribute__((alias("zsyrk32_")));


void zsyrk64_(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* beta, double complex* c, int64_t* ldc)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* n, void* k, void* alpha, void* a, void* lda, void* beta, void* c, void* ldc);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _ldc32; void* _pldc;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.zsyrk.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
			current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.zsyrk.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) n, (void*) k, (void*) alpha, (void*) a, (void*) lda, (void*) beta, (void*) c, (void*) ldc); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldc > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of zsyrk64 the parameter ldc is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldc32 = (int32_t) *ldc;
		_pldc = &_ldc32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "zsyrk64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
		current_backend->blas.zsyrk.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.zsyrk.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) _pn, (void*) _pk, (void*) alpha, (void*) a, (void*) _plda, (void*) beta, (void*) c, (void*) _pldc); 
	} 
	return;
}
void zsyrk64(char* uplo, char* trans, int64_t* n, int64_t* k, double complex* alpha, double complex* a, int64_t* lda, double complex* beta, double complex* c, int64_t* ldc) __attribute__((alias("zsyrk64_")));



void ztbmv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbmv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx) __attribute__((alias("ztbmv_")));


void ztbmv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double complex* a, int32_t* lda, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbmv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double complex* a, int32_t* lda, double complex* x, int32_t* incx) __attribute__((alias("ztbmv32_")));


void ztbmv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double complex* a, int64_t* lda, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbmv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double complex* a, int64_t* lda, double complex* x, int64_t* incx) __attribute__((alias("ztbmv64_")));



void ztbsv_(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _k32; int64_t _k64; void* _pk;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbsv(char* uplo, char* trans, char* diag, blasint* n, blasint* k, double complex* a, blasint* lda, double complex* x, blasint* incx) __attribute__((alias("ztbsv_")));


void ztbsv32_(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double complex* a, int32_t* lda, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _k64; void* _pk;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_k64 = (int64_t)*k;
		_pk = &_k64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbsv32(char* uplo, char* trans, char* diag, int32_t* n, int32_t* k, double complex* a, int32_t* lda, double complex* x, int32_t* incx) __attribute__((alias("ztbsv32_")));


void ztbsv64_(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double complex* a, int64_t* lda, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* k, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _k32; void* _pk;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztbsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztbsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) k, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *k > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv64 the parameter k is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztbsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_k32 = (int32_t) *k;
		_pk = &_k32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztbsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztbsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztbsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) _pk, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztbsv64(char* uplo, char* trans, char* diag, int64_t* n, int64_t* k, double complex* a, int64_t* lda, double complex* x, int64_t* incx) __attribute__((alias("ztbsv64_")));



void ztpmv_(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpmv(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx) __attribute__((alias("ztpmv_")));


void ztpmv32_(char* uplo, char* trans, char* diag, int32_t* n, double complex* ap, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpmv32(char* uplo, char* trans, char* diag, int32_t* n, double complex* ap, double complex* x, int32_t* incx) __attribute__((alias("ztpmv32_")));


void ztpmv64_(char* uplo, char* trans, char* diag, int64_t* n, double complex* ap, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpmv64(char* uplo, char* trans, char* diag, int64_t* n, double complex* ap, double complex* x, int64_t* incx) __attribute__((alias("ztpmv64_")));



void ztpsv_(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpsv(char* uplo, char* trans, char* diag, blasint* n, double complex* ap, double complex* x, blasint* incx) __attribute__((alias("ztpsv_")));


void ztpsv32_(char* uplo, char* trans, char* diag, int32_t* n, double complex* ap, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpsv32(char* uplo, char* trans, char* diag, int32_t* n, double complex* ap, double complex* x, int32_t* incx) __attribute__((alias("ztpsv32_")));


void ztpsv64_(char* uplo, char* trans, char* diag, int64_t* n, double complex* ap, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* ap, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztpsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
			current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztpsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) ap, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztpsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztpsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
		current_backend->blas.ztpsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztpsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) ap, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztpsv64(char* uplo, char* trans, char* diag, int64_t* n, double complex* ap, double complex* x, int64_t* incx) __attribute__((alias("ztpsv64_")));



void ztrmm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrmm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb) __attribute__((alias("ztrmm_")));


void ztrmm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrmm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb) __attribute__((alias("ztrmm32_")));


void ztrmm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrmm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrmm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb) __attribute__((alias("ztrmm64_")));



void ztrmv_(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrmv(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx) __attribute__((alias("ztrmv_")));


void ztrmv32_(char* uplo, char* trans, char* diag, int32_t* n, double complex* a, int32_t* lda, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrmv32(char* uplo, char* trans, char* diag, int32_t* n, double complex* a, int32_t* lda, double complex* x, int32_t* incx) __attribute__((alias("ztrmv32_")));


void ztrmv64_(char* uplo, char* trans, char* diag, int64_t* n, double complex* a, int64_t* lda, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrmv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrmv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrmv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrmv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrmv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrmv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrmv64(char* uplo, char* trans, char* diag, int64_t* n, double complex* a, int64_t* lda, double complex* x, int64_t* incx) __attribute__((alias("ztrmv64_")));



void ztrsm_(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; int64_t _m64; void* _pm;
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _ldb32; int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsm - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrsm(char* side, char* uplo, char* transa, char* diag, blasint* m, blasint* n, double complex* alpha, double complex* a, blasint* lda, double complex* b, blasint* ldb) __attribute__((alias("ztrsm_")));


void ztrsm32_(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int64_t _m64; void* _pm;
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _ldb64; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_m64 = (int64_t)*m;
		_pm = &_m64;
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_ldb64 = (int64_t)*ldb;
		_pldb = &_ldb64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsm32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrsm32(char* side, char* uplo, char* transa, char* diag, int32_t* m, int32_t* n, double complex* alpha, double complex* a, int32_t* lda, double complex* b, int32_t* ldb) __attribute__((alias("ztrsm32_")));


void ztrsm64_(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb)
{
	double ts;
	void (*fn) (void* side, void* uplo, void* transa, void* diag, void* m, void* n, void* alpha, void* a, void* lda, void* b, void* ldb);
	int32_t _m32; void* _pm;
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _ldb32; void* _pldb;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsm.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
			current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsm.calls[0]++;
		} else { 
				fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) m, (void*) n, (void*) alpha, (void*) a, (void*) lda, (void*) b, (void*) ldb); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *m > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm64 the parameter m is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *ldb > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsm64 the parameter ldb is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_m32 = (int32_t) *m;
		_pm = &_m32;
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_ldb32 = (int32_t) *ldb;
		_pldb = &_ldb32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsm64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
		current_backend->blas.ztrsm.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsm.calls[0]++;
	} else { 
		fn((void*) side, (void*) uplo, (void*) transa, (void*) diag, (void*) _pm, (void*) _pn, (void*) alpha, (void*) a, (void*) _plda, (void*) b, (void*) _pldb); 
	} 
	return;
}
void ztrsm64(char* side, char* uplo, char* transa, char* diag, int64_t* m, int64_t* n, double complex* alpha, double complex* a, int64_t* lda, double complex* b, int64_t* ldb) __attribute__((alias("ztrsm64_")));



void ztrsv_(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; int64_t _n64; void* _pn;
	int32_t _lda32; int64_t _lda64; void* _plda;
	int32_t _incx32; int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(blasint) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(blasint) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsv - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrsv(char* uplo, char* trans, char* diag, blasint* n, double complex* a, blasint* lda, double complex* x, blasint* incx) __attribute__((alias("ztrsv_")));


void ztrsv32_(char* uplo, char* trans, char* diag, int32_t* n, double complex* a, int32_t* lda, double complex* x, int32_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int64_t _n64; void* _pn;
	int64_t _lda64; void* _plda;
	int64_t _incx64; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int32_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if (current_backend->info.backend_integer_size == 8) {
		_n64 = (int64_t)*n;
		_pn = &_n64;
		_lda64 = (int64_t)*lda;
		_plda = &_lda64;
		_incx64 = (int64_t)*incx;
		_pincx = &_incx64;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsv32 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrsv32(char* uplo, char* trans, char* diag, int32_t* n, double complex* a, int32_t* lda, double complex* x, int32_t* incx) __attribute__((alias("ztrsv32_")));


void ztrsv64_(char* uplo, char* trans, char* diag, int64_t* n, double complex* a, int64_t* lda, double complex* x, int64_t* incx)
{
	double ts;
	void (*fn) (void* uplo, void* trans, void* diag, void* n, void* a, void* lda, void* x, void* incx);
	int32_t _n32; void* _pn;
	int32_t _lda32; void* _plda;
	int32_t _incx32; void* _pincx;
	if ( current_backend->post_init != 0 ) {
		__flexiblas_backend_init(current_backend); 
		current_backend->post_init = 0; 
	}
	fn = current_backend->blas.ztrsv.call_fblas; 
	if (current_backend->info.backend_integer_size == sizeof(int64_t) ) { 
		if ( __flexiblas_profile ) {
			ts = flexiblas_wtime(); 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
			current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
			current_backend->blas.ztrsv.calls[0]++;
		} else { 
				fn((void*) uplo, (void*) trans, (void*) diag, (void*) n, (void*) a, (void*) lda, (void*) x, (void*) incx); 
		} 
		return;
	}
	else if ( current_backend->info.backend_integer_size == 4) {
		if ( sizeof(int64_t) > 4 ) {
			if ( *n > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv64 the parameter n is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *lda > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv64 the parameter lda is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
			if ( *incx > __INT32_MAX__) {
				fprintf(stderr,"*** On entry of ztrsv64 the parameter incx is out of int32_t range (> %d). This might cause trouble. ***\n", __INT32_MAX__);
			}
		}
		_n32 = (int32_t) *n;
		_pn = &_n32;
		_lda32 = (int32_t) *lda;
		_plda = &_lda32;
		_incx32 = (int32_t) *incx;
		_pincx = &_incx32;
	}
	else {
		fprintf(stderr, PRINT_PREFIX "ztrsv64 - can not convert integer types");
		abort();
	}

	if ( __flexiblas_profile ) {
		ts = flexiblas_wtime(); 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
		current_backend->blas.ztrsv.timings[0] += (flexiblas_wtime() -ts);
		current_backend->blas.ztrsv.calls[0]++;
	} else { 
		fn((void*) uplo, (void*) trans, (void*) diag, (void*) _pn, (void*) a, (void*) _plda, (void*) x, (void*) _pincx); 
	} 
	return;
}
void ztrsv64(char* uplo, char* trans, char* diag, int64_t* n, double complex* a, int64_t* lda, double complex* x, int64_t* incx) __attribute__((alias("ztrsv64_")));



